diff -rupN ./src/org/cloudcmp/tasks/compute/compress/Compress.java ./src/org/cloudcmp/tasks/compute_full/compress/Compress.java
--- ./src/org/cloudcmp/tasks/compute/compress/Compress.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/compress/Compress.java	2011-11-16 17:05:00.000000000 -0500
@@ -30,7 +30,7 @@
  * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks.compress;
+package org.cloudcmp.tasks.compute.compress;
 
 import java.util.zip.CRC32;
 
@@ -440,7 +440,7 @@ final class Compressor extends CompBase
         }
     }
     
-    static final class HashTable { // moved 4/15/98 dm/kmd
+    final class HashTable { // moved 4/15/98 dm/kmd
         /*
          * Use protected instead of private to allow access by parent class of inner
          * class. wnb 4/17/98
@@ -651,7 +651,7 @@ final class Decompressor extends CompBas
     }
     
     
-    static final class DeStack { // moved 4/15/98 dm/kmd
+    final class DeStack { // moved 4/15/98 dm/kmd
         /*
          * Use protected instead of private to allow access by parent class of inner
          * class. wnb 4/17/98
@@ -679,7 +679,7 @@ final class Decompressor extends CompBas
     }
     
     
-    static final class SuffixTable {
+    final class SuffixTable {
         protected byte tab[];
         public SuffixTable() {
             tab = new byte[Compress.SUFFIX_TAB_SZ];
diff -rupN ./src/org/cloudcmp/tasks/compute/compress/CompressTask.java ./src/org/cloudcmp/tasks/compute_full/compress/CompressTask.java
--- ./src/org/cloudcmp/tasks/compute/compress/CompressTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/compress/CompressTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -8,131 +8,163 @@
  * source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks.compress;
+package org.cloudcmp.tasks.compute.compress;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
 import java.util.zip.CRC32;
-import spec.harness.Context;
-import spec.harness.Launch;
 
-public final class Harness {
-    public static final String[] FILES_NAMES = new String[] {
-        "resources/compress/input/202.tar",
-        "resources/compress/input/205.tar",
-        "resources/compress/input/208.tar",
-        "resources/compress/input/209.tar",
-        "resources/compress/input/210.tar",
-        "resources/compress/input/211.tar",
-        "resources/compress/input/213x.tar",
-        "resources/compress/input/228.tar",
-        "resources/compress/input/239.tar",
-        "resources/compress/input/misc.tar"};
-    
-    public static final int FILES_NUMBER = FILES_NAMES.length;
-    public static final int LOOP_COUNT = 2;
-    public static Source[] SOURCES;
-    public static byte[][] COMPRESS_BUFFERS;
-    public static byte[][] DECOMPRESS_BUFFERS;
-    public static Compress CB;
-    
-    public void runCompress(int btid) {
-        spec.harness.Context.getOut().println("Loop count = " + LOOP_COUNT);
-        for (int i = 0; i < LOOP_COUNT; i++) {
-            for (int j = 0; j < FILES_NUMBER; j++) {
-                Source source = SOURCES[j];
-                OutputBuffer comprBuffer, decomprBufer;
-                comprBuffer = CB.performAction(source.getBuffer(),
-                        source.getLength(),
-                        CB.COMPRESS,
-                        COMPRESS_BUFFERS[btid - 1]);
-                decomprBufer = CB.performAction(COMPRESS_BUFFERS[btid - 1],
-                        comprBuffer.getLength(),
-                        CB.UNCOMPRESS,
-                        DECOMPRESS_BUFFERS[btid - 1]);
-                Context.getOut().print(source.getLength() + " " + source.getCRC() + " ");
-                Context.getOut().print(comprBuffer.getLength() + comprBuffer.getCRC() + " ");
-                Context.getOut().println(decomprBufer.getLength() + " " + decomprBufer.getCRC());
-            }
-        }
-    }
-    
-    public long inst_main(int btid) {
-        long startTime = System.currentTimeMillis();
-        runCompress(btid);
-        return System.currentTimeMillis() - startTime;
-    }
-    
-    static void prepareBuffers() {
-        CB = new Compress();
-        SOURCES = new Source[FILES_NUMBER];
-        for (int i = 0; i < FILES_NUMBER; i ++) {
-            SOURCES[i] = new Source(Context.getSpecBasePath() + "/" + FILES_NAMES[i]);
-        }
-        DECOMPRESS_BUFFERS = new byte[Launch.currentNumberBmThreads][Source.MAX_LENGTH];
-        COMPRESS_BUFFERS = new byte[Launch.currentNumberBmThreads][Source.MAX_LENGTH];
-    }
-    
-    static class Source {
-        private byte[] buffer;
-        private long crc;
-        private int length;
-        static int MAX_LENGTH;
-        
-        public Source(String fileName) {
-            buffer = fillBuffer(fileName);
-            length = buffer.length;
-            MAX_LENGTH = Math.max(length, MAX_LENGTH);
-            CRC32 crc32 = new CRC32();
-            crc32.update(buffer, 0, length);
-            crc = crc32.getValue();
-        }
-        
-        long getCRC() {
-            return crc;
-        }
-        
-        int getLength() {
-            return length;
-        }
-        
-        byte[] getBuffer() {
-            return buffer;
-        }
-        
-        private static byte[] fillBuffer(String fileName) {
-            try {
-                FileInputStream sif = new FileInputStream(fileName);
-                int length = (int) new File(fileName).length();
-                int counter = 0;
-                
-                // Only allocate size of input file rather than MAX - kmd
-                // If compressed file is larger than input file this allocation
-                // will fail and out of bound exception will occur
-                // In real lie, compress will no do any compression as no
-                // space is saved.-- kaivalya
-                byte[] result = new byte[length];
-                
-                int bytes_read;
-                while ((bytes_read = sif.read(result, counter,
-                        (length - counter))) > 0) {
-                    counter += bytes_read;
-                }
-                
-                sif.close(); // release resources
-                
-                if (counter != length) {
-                    spec.harness.Context.getOut().println(
-                            "ERROR reading test input file");
-                }
-                return result;
-            } catch (IOException e) {
-                e.printStackTrace(Context.getOut());
-            }
-            
-            return null;
-        }
-    }
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+
+public class CompressTask extends ComputeTask {
+	public CompressTask(Adaptor adaptor) {
+		super(adaptor);
+		if (adaptor != null) {
+			String resourcePath = adaptor.configs.get("resource_dir");
+			fileNames.add(resourcePath + "/compress/input/202.tar");
+			fileNames.add(resourcePath + "/compress/input/205.tar");
+			fileNames.add(resourcePath + "/compress/input/208.tar");
+			fileNames.add(resourcePath + "/compress/input/209.tar");
+			fileNames.add(resourcePath + "/compress/input/210.tar");
+			fileNames.add(resourcePath + "/compress/input/211.tar");
+			fileNames.add(resourcePath + "/compress/input/213x.tar");
+			fileNames.add(resourcePath + "/compress/input/228.tar");
+			fileNames.add(resourcePath + "/compress/input/239.tar");
+			fileNames.add(resourcePath + "/compress/input/misc.tar");
+		}
+	}
+	
+	public String getTaskName() {
+		return "compress";
+	}
+
+	public List<String> fileNames = new ArrayList<String>();
+	
+	protected SingleComputeTask getSingleComputeTask() {
+		return new SingleComputeTask();
+	}
+
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		public static final int LOOP_COUNT = 2;
+		public Source[] SOURCES;
+		public byte[][] COMPRESS_BUFFERS;
+		public byte[][] DECOMPRESS_BUFFERS;
+		public Compress CB;
+		
+		public int MAX_LENGTH;
+		
+		public void realRun() {
+			prepareBuffers();
+			for (int i = 0; i < LOOP_COUNT; i++) {
+				for (int j = 0; j < fileNames.size(); j++) {
+					Source source = SOURCES[j];
+					OutputBuffer comprBuffer, decomprBufer;
+					comprBuffer = CB.performAction(source.getBuffer(),
+							source.getLength(),
+							CB.COMPRESS,
+							COMPRESS_BUFFERS[0]);
+					decomprBufer = CB.performAction(COMPRESS_BUFFERS[0],
+							comprBuffer.getLength(),
+							CB.UNCOMPRESS,
+							DECOMPRESS_BUFFERS[0]);
+				}
+			}	
+		}
+		
+		void prepareBuffers() {
+			CB = new Compress();
+			SOURCES = new Source[fileNames.size()];
+			for (int i = 0; i < fileNames.size(); i ++) {
+				SOURCES[i] = new Source(fileNames.get(i));
+			}
+			DECOMPRESS_BUFFERS = new byte[1][MAX_LENGTH];
+			COMPRESS_BUFFERS = new byte[1][MAX_LENGTH];
+		}
+
+		public class Source {
+			private byte[] buffer;
+			private long crc;
+			private int length;
+
+			public Source(String fileName) {
+				buffer = fillBuffer(fileName);
+				length = buffer.length;
+				MAX_LENGTH = Math.max(length, MAX_LENGTH);
+				CRC32 crc32 = new CRC32();
+				crc32.update(buffer, 0, length);
+				crc = crc32.getValue();
+			}
+
+			long getCRC() {
+				return crc;
+			}
+
+			int getLength() {
+				return length;
+			}
+
+			byte[] getBuffer() {
+				return buffer;
+			}
+
+			private byte[] fillBuffer(String fileName) {
+				try {
+					FileInputStream sif = new FileInputStream(fileName);
+					int length = (int) new File(fileName).length();
+					int counter = 0;
+
+					// Only allocate size of input file rather than MAX - kmd
+					// If compressed file is larger than input file this allocation
+					// will fail and out of bound exception will occur
+					// In real lie, compress will no do any compression as no
+					// space is saved.-- kaivalya
+					byte[] result = new byte[length];
+
+					int bytes_read;
+					while ((bytes_read = sif.read(result, counter,
+									(length - counter))) > 0) {
+						counter += bytes_read;
+					}
+
+					sif.close(); // release resources
+
+					if (counter != length) {
+						System.out.println(
+								"ERROR reading test input file");
+					}
+					
+					// for debug			
+					return result;
+				} catch (IOException e) {
+				}
+
+				return null;
+			}
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		CompressTask task = new CompressTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
 }
 
diff -rupN ./src/org/cloudcmp/tasks/compute/crypto/aes/CryptoAESTask.java ./src/org/cloudcmp/tasks/compute_full/crypto/aes/CryptoAESTask.java
--- ./src/org/cloudcmp/tasks/compute/crypto/aes/CryptoAESTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/crypto/aes/CryptoAESTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,171 +5,199 @@
  * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks.crypto.aes;
+package org.cloudcmp.tasks.compute.crypto.aes;
 
 import java.security.AlgorithmParameters;
 import java.security.SecureRandom;
+import java.util.Map;
 
 import javax.crypto.Cipher;
 import javax.crypto.KeyGenerator;
 import javax.crypto.SecretKey;
 
-import spec.benchmarks.crypto.Util;
-import spec.harness.Context;
-import spec.harness.SpecJVMBenchmarkBase;
-import spec.harness.StopBenchmarkException;
-import spec.harness.results.BenchmarkResult;
-
-public class Main extends SpecJVMBenchmarkBase {
-    
-    public final static boolean DEBUG = false;
-    
-    final static int aesKeySize = 128;
-    final static int desKeySize = 168;
-    final static int level = 12;
-    
-    static SecretKey aesKey = null;
-    static SecretKey desKey = null;
-    
-    static KeyGenerator aesKeyGen = null;
-    static KeyGenerator desKeyGen = null;
-    
-    AlgorithmParameters algorithmParameters;
-    
-    public Main(BenchmarkResult bmResult, int threadId) {
-        super(bmResult, threadId);
-        algorithmParameters = null;
-    }
-    
-    /** Run this in multi mode, next to each other. */
-    public static String testType() {
-        return MULTI;
-    }
-    
-    private void printMe(String name, byte [] arr) {
-        System.out.print("  " + name + ":");
-        for (int i = 0; i < arr.length; i++) {
-            System.out.print(arr[i]);
-        }
-        System.out.println();
-    }
-    
-    /**
-     * Will encrypt the indata level number of times.
-     * @param indata Data to encrypt.
-     * @param key Key to use for encryption.
-     * @param algorithm Algorithm/Standard to use.
-     * @param level Number of times to encrypt.
-     * @return The encrypted version of indata.
-     */
-    private byte[] encrypt(byte [] indata, SecretKey key, String algorithm, int level) {
-        
-        if (DEBUG) printMe("indata", indata);
-        
-        byte[] result = indata;
-        
-        try {
-            Cipher c = Cipher.getInstance(algorithm);
-            c.init(Cipher.ENCRYPT_MODE, key);
-            algorithmParameters = c.getParameters();
-            
-            for (int i = 0; i < level; i++) {
-                byte[] r1 = c.update(result);
-                byte[] r2 = c.doFinal();
-                
-                if (DEBUG) printMe("[" + i + "] r1", r1);
-                if (DEBUG) printMe("[" + i + "] r2", r2);
-                
-                result = new byte[r1.length + r2.length];
-                System.arraycopy(r1, 0, result, 0, r1.length);
-                System.arraycopy(r2, 0, result, r1.length, r2.length);
-            }
-        } catch (Exception e) {
-            throw new StopBenchmarkException("Exception in encrypt for " + algorithm + ".", e);
-        }
-        
-        if (DEBUG) printMe("result", result);
-        return result;
-    }
-    
-    /**
-     * Will decrypt the indata level number of times.
-     * @param indata Data to decrypt.
-     * @param key Key to use for encryption.
-     * @param algorithm
-     * @param level
-     * @return
-     */
-    private byte[] decrypt(byte[] indata, SecretKey key, String algorithm, int level) {
-        
-        if (DEBUG) printMe("indata", indata);
-        
-        byte[] result = indata;
-        
-        try {
-            Cipher c = Cipher.getInstance(algorithm);
-            c.init(Cipher.DECRYPT_MODE, key, algorithmParameters);
-            
-            for (int i = 0; i < level; i++) {
-                byte[] r1 = c.update(result);
-                byte[] r2 = c.doFinal();
-                if (DEBUG) printMe("[" + i + "] r1", r1);
-                if (DEBUG) printMe("[" + i + "] r2", r2);
-                
-                result = new byte[r1.length + r2.length];
-                System.arraycopy(r1, 0, result, 0, r1.length);
-                System.arraycopy(r2, 0, result, r1.length, r2.length);
-            }
-            
-        } catch (Exception e) {
-            throw new StopBenchmarkException("Exception in encrypt for " + algorithm + ".", e);
-        }
-        
-        if (DEBUG) printMe("result", result);
-        return result;
-    }
-    
-    public void runEncryptDecrypt(SecretKey key, String algorithm, String inputFile) {
-        byte [] indata = Util.getTestData(inputFile);
-        byte [] cipher = encrypt(indata, key, algorithm, level);
-        byte [] plain = decrypt(cipher, key, algorithm, level);
-        boolean match = Util.check(indata, plain);
-        Context.getOut().println(algorithm + ":" + " plaincheck="
-                + Util.checkSum(plain) + (match ? " PASS" : " FAIL"));
-    }
-    
-    public void harnessMain() {
-        runEncryptDecrypt(Main.aesKey, "AES/CBC/NoPadding", Util.TEST_DATA_1);
-        runEncryptDecrypt(Main.aesKey, "AES/CBC/PKCS5Padding", Util.TEST_DATA_1);
-        runEncryptDecrypt(Main.desKey, "DESede/CBC/NoPadding", Util.TEST_DATA_1);
-        runEncryptDecrypt(Main.desKey, "DESede/CBC/PKCS5Padding", Util.TEST_DATA_1);
-        runEncryptDecrypt(Main.aesKey, "AES/CBC/NoPadding", Util.TEST_DATA_2);
-        runEncryptDecrypt(Main.aesKey, "AES/CBC/PKCS5Padding", Util.TEST_DATA_2);
-        runEncryptDecrypt(Main.desKey, "DESede/CBC/NoPadding", Util.TEST_DATA_2);
-        runEncryptDecrypt(Main.desKey, "DESede/CBC/PKCS5Padding", Util.TEST_DATA_2);
-    }
-    
-    public static void setupBenchmark() {
-        try {
-            byte [] seed =  {0x4, 0x7, 0x1, 0x1};
-            SecureRandom random = new SecureRandom(seed);
-            Context.getFileCache().loadFile(Util.TEST_DATA_1);
-            Context.getFileCache().loadFile(Util.TEST_DATA_2);
-            aesKeyGen = KeyGenerator.getInstance("AES");
-            aesKeyGen.init(aesKeySize, random);
-            desKeyGen = KeyGenerator.getInstance("DESede");
-            desKeyGen.init(desKeySize, random);
-            aesKey = aesKeyGen.generateKey();
-            desKey = desKeyGen.generateKey();
-        } catch (Exception e) {
-            throw new StopBenchmarkException("Error in setup of crypto.aes." + e);
-        }
-    }
-    
-    public static void main(String[] args) throws Exception {
-        //setupBenchmark();
-        //Main m = new Main(new BenchmarkResult(), 0);
-        //m.harnessMain();
-        runSimple(Main.class, args);
-    }
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+import org.cloudcmp.tasks.compute.crypto.Util;
+
+public class CryptoAESTask extends ComputeTask {
+	private String resourcePath;
+	
+	public CryptoAESTask(Adaptor adaptor) {
+		super(adaptor);
+		if (adaptor != null) {
+			resourcePath = adaptor.configs.get("resource_dir");
+		}
+	}
+
+	public String getTaskName() {
+		return "crypto.aes";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {
+		return new SingleComputeTask();
+	}
+
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		public final static boolean DEBUG = false;
+
+		final static int aesKeySize = 128;
+		final static int desKeySize = 168;
+		final static int level = 12;
+
+		SecretKey aesKey = null;
+		SecretKey desKey = null;
+
+		KeyGenerator aesKeyGen = null;
+		KeyGenerator desKeyGen = null;
+
+		AlgorithmParameters algorithmParameters = null;
+
+		private void printMe(String name, byte [] arr) {
+			System.out.print("  " + name + ":");
+			for (int i = 0; i < arr.length; i++) {
+				System.out.print(arr[i]);
+			}
+			System.out.println();
+		}
+
+		/**
+		 * Will encrypt the indata level number of times.
+		 * @param indata Data to encrypt.
+		 * @param key Key to use for encryption.
+		 * @param algorithm Algorithm/Standard to use.
+		 * @param level Number of times to encrypt.
+		 * @return The encrypted version of indata.
+		 */
+		private byte[] encrypt(byte [] indata, SecretKey key, String algorithm, int level) {
+
+			if (DEBUG) printMe("indata", indata);
+
+			byte[] result = indata;
+
+			try {
+				Cipher c = Cipher.getInstance(algorithm);
+				c.init(Cipher.ENCRYPT_MODE, key);
+				algorithmParameters = c.getParameters();
+
+				for (int i = 0; i < level; i++) {
+					byte[] r1 = c.update(result);
+					byte[] r2 = c.doFinal();
+
+					if (DEBUG) printMe("[" + i + "] r1", r1);
+					if (DEBUG) printMe("[" + i + "] r2", r2);
+
+					result = new byte[r1.length + r2.length];
+					System.arraycopy(r1, 0, result, 0, r1.length);
+					System.arraycopy(r2, 0, result, r1.length, r2.length);
+				}
+			} catch (Exception e) {
+			}
+
+			if (DEBUG) printMe("result", result);
+			return result;
+		}
+
+		/**
+		 * Will decrypt the indata level number of times.
+		 * @param indata Data to decrypt.
+		 * @param key Key to use for encryption.
+		 * @param algorithm
+		 * @param level
+		 * @return
+		 */
+		private byte[] decrypt(byte[] indata, SecretKey key, String algorithm, int level) {
+
+			if (DEBUG) printMe("indata", indata);
+
+			byte[] result = indata;
+
+			try {
+				Cipher c = Cipher.getInstance(algorithm);
+				c.init(Cipher.DECRYPT_MODE, key, algorithmParameters);
+
+				for (int i = 0; i < level; i++) {
+					byte[] r1 = c.update(result);
+					byte[] r2 = c.doFinal();
+					if (DEBUG) printMe("[" + i + "] r1", r1);
+					if (DEBUG) printMe("[" + i + "] r2", r2);
+
+					result = new byte[r1.length + r2.length];
+					System.arraycopy(r1, 0, result, 0, r1.length);
+					System.arraycopy(r2, 0, result, r1.length, r2.length);
+				}
+
+			} catch (Exception e) {
+			}
+
+			if (DEBUG) printMe("result", result);
+			return result;
+		}
+
+		public void runEncryptDecrypt(SecretKey key, String algorithm, String inputFile) {
+			// for debug
+			byte [] indata = Util.getTestData(inputFile);
+			byte [] cipher = encrypt(indata, key, algorithm, level);
+			byte [] plain = decrypt(cipher, key, algorithm, level);
+			boolean match = Util.check(indata, plain);
+		}
+
+		public long runTask() {
+			long startTime = System.currentTimeMillis();
+			setupBenchmark();
+			runEncryptDecrypt(aesKey, "AES/CBC/NoPadding", resourcePath + Util.TEST_DATA_1);
+			runEncryptDecrypt(aesKey, "AES/CBC/PKCS5Padding", resourcePath + Util.TEST_DATA_1);
+			runEncryptDecrypt(desKey, "DESede/CBC/NoPadding", resourcePath + Util.TEST_DATA_1);
+			runEncryptDecrypt(desKey, "DESede/CBC/PKCS5Padding", resourcePath + Util.TEST_DATA_1);
+			runEncryptDecrypt(aesKey, "AES/CBC/NoPadding", resourcePath + Util.TEST_DATA_2);
+			runEncryptDecrypt(aesKey, "AES/CBC/PKCS5Padding", resourcePath + Util.TEST_DATA_2);
+			runEncryptDecrypt(desKey, "DESede/CBC/NoPadding", resourcePath + Util.TEST_DATA_2);
+			runEncryptDecrypt(desKey, "DESede/CBC/PKCS5Padding", resourcePath + Util.TEST_DATA_2);
+			return System.currentTimeMillis() - startTime;
+		}
+
+		public void setupBenchmark() {
+			try {
+				byte [] seed =  {0x4, 0x7, 0x1, 0x1};
+				SecureRandom random = new SecureRandom(seed);
+				aesKeyGen = KeyGenerator.getInstance("AES");
+				aesKeyGen.init(aesKeySize, random);
+				desKeyGen = KeyGenerator.getInstance("DESede");
+				desKeyGen.init(desKeySize, random);
+				aesKey = aesKeyGen.generateKey();
+				desKey = desKeyGen.generateKey();
+			} catch (Exception e) {
+			}
+		}
+		
+		public void realRun() {
+			setupBenchmark();
+			runEncryptDecrypt(aesKey, "AES/CBC/NoPadding", resourcePath + Util.TEST_DATA_1);
+			runEncryptDecrypt(aesKey, "AES/CBC/PKCS5Padding", resourcePath + Util.TEST_DATA_1);
+			runEncryptDecrypt(desKey, "DESede/CBC/NoPadding", resourcePath + Util.TEST_DATA_1);
+			runEncryptDecrypt(desKey, "DESede/CBC/PKCS5Padding", resourcePath + Util.TEST_DATA_1);
+			runEncryptDecrypt(aesKey, "AES/CBC/NoPadding", resourcePath + Util.TEST_DATA_2);
+			runEncryptDecrypt(aesKey, "AES/CBC/PKCS5Padding", resourcePath + Util.TEST_DATA_2);
+			runEncryptDecrypt(desKey, "DESede/CBC/NoPadding", resourcePath + Util.TEST_DATA_2);
+			runEncryptDecrypt(desKey, "DESede/CBC/PKCS5Padding", resourcePath + Util.TEST_DATA_2);
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		CryptoAESTask task = new CryptoAESTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
 }
diff -rupN ./src/org/cloudcmp/tasks/compute/crypto/rsa/CryptoRSATask.java ./src/org/cloudcmp/tasks/compute_full/crypto/rsa/CryptoRSATask.java
--- ./src/org/cloudcmp/tasks/compute/crypto/rsa/CryptoRSATask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/crypto/rsa/CryptoRSATask.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,144 +5,149 @@
  * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks.crypto.rsa;
+package org.cloudcmp.tasks.compute.crypto.rsa;
 
 import java.security.KeyPair;
 import java.security.KeyPairGenerator;
 import java.security.PrivateKey;
 import java.security.PublicKey;
+import java.util.Map;
 
 import javax.crypto.Cipher;
 
-import spec.benchmarks.crypto.Util;
-import spec.harness.Context;
-import spec.harness.SpecJVMBenchmarkBase;
-import spec.harness.StopBenchmarkException;
-import spec.harness.results.BenchmarkResult;
-
-public class Main extends SpecJVMBenchmarkBase {
-    
-    final static int level = 1;
-    
-    static PublicKey rsaPub;
-    static PrivateKey rsaPriv;
-    
-    public Main(BenchmarkResult bmResult, int threadId) {
-        super(bmResult, threadId);
-    }
-    
-    /** Run this in multi mode, next to each other. */
-    public static String testType() {
-        return MULTI;
-    }
-    
-    public byte [] encrypt(byte[] indata, String algorithm) {
-        
-        try {
-            Cipher c = Cipher.getInstance(algorithm);
-            byte[] result = indata;
-            
-            c.init(Cipher.ENCRYPT_MODE, rsaPub);
-            result = c.doFinal(result);
-            
-            return result;
-            
-        } catch (Exception e) {
-            throw new StopBenchmarkException("Exception in encrypt for " + algorithm + ".", e);
-        }
-    }
-    
-    public byte[] decrypt(byte[] indata, String algorithm) {
-        
-        try {
-            Cipher c = Cipher.getInstance(algorithm);
-            
-            byte[] result = indata;
-            
-            c.init(Cipher.DECRYPT_MODE, rsaPriv);
-            result = c.doFinal(result);
-            
-            return result;
-            
-        } catch (Exception e) {
-            throw new StopBenchmarkException("Exception in decrypt for " + algorithm + ".", e);
-        }
-    }
-    
-    public void runSingleEncryptDecrypt(String algorithm, String inputFile) {
-        byte [] indata = Util.getTestData(inputFile);
-        Context.getOut().println("Algorithm=" + algorithm + " indata length=" + indata.length);
-        byte [] cipher = encrypt(indata, algorithm);
-        byte [] plain = decrypt(cipher, algorithm);
-        boolean match = Util.check(indata, plain);
-        Context.getOut().println(algorithm + ":"
-                + " plaincheck=" + Util.checkSum(plain)
-                + (match ? " PASS" : " FAIL"));
-    }
-    
-    public void runMultiEncryptDecrypt(String algorithm, String inputFile) {
-        int blockSize = 64;
-        byte [] fullIndata = Util.getTestData(inputFile);
-        byte [] indata = new byte[blockSize];
-        int pass = 0;
-        int fail = 0;
-        int check = 0;
-        Context.getOut().println("Algorithm=" + algorithm + " indata length=" + fullIndata.length);
-        for (int i = 0; i + blockSize < fullIndata.length; i+= blockSize) {
-            System.arraycopy(fullIndata, i, indata, 0, blockSize);
-            byte [] cipher = encrypt(indata, algorithm);
-            byte [] plain = decrypt(cipher, algorithm);
-            if (Util.check(indata, plain)) {
-                pass++;
-                check += Util.checkSum(plain);
-            } else {
-                fail++;
-            }
-        }
-        Context.getOut().println(algorithm + ":"
-                + " checksum=" + check
-                + " pass=" + pass
-                + " fail=" + fail);
-    }
-    
-    public void harnessMain() {
-        runSingleEncryptDecrypt("RSA/ECB/PKCS1Padding", Util.TEST_DATA_3);
-        runMultiEncryptDecrypt("RSA/ECB/PKCS1Padding", Util.TEST_DATA_5);
-        // Run some more, in order to increase operation workload.
-        runSingleEncryptDecrypt("RSA/ECB/PKCS1Padding", Util.TEST_DATA_3);
-        runMultiEncryptDecrypt("RSA/ECB/PKCS1Padding", Util.TEST_DATA_5);
-        runSingleEncryptDecrypt("RSA/ECB/PKCS1Padding", Util.TEST_DATA_3);
-    }
-    
-    public static void setupBenchmark() {
-        try {
-            Context.getFileCache().loadFile(Util.TEST_DATA_3);
-            Context.getFileCache().loadFile(Util.TEST_DATA_5);
-            
-            KeyPairGenerator rsaKeyPairGen = KeyPairGenerator.getInstance("RSA");
-            // 512, 768 and 1024 are commonly used
-            rsaKeyPairGen.initialize(1024);
-            
-            KeyPair rsaKeyPair = rsaKeyPairGen.generateKeyPair();
-            
-            rsaPub = rsaKeyPair.getPublic();
-            rsaPriv = rsaKeyPair.getPrivate();
-            
-        } catch (Exception e) {
-            throw new StopBenchmarkException("Error in setup of crypto.aes." + e);
-        }
-    }
-    
-    public static void main(String[] args) throws Exception {
-        
-        // Used to create 96 bytes random data for input
-        // Util.createRandomTestData(Util.TEST_DATA_3, );
-        
-        runSimple(Main.class, args);
-        
-        //setupBenchmark();
-        //Main m = new Main(new BenchmarkResult(), 0);
-        //m.harnessMain();
-    }
-    
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+import org.cloudcmp.tasks.compute.crypto.Util;
+
+public class CryptoRSATask extends ComputeTask {
+	private String resourcePath;
+	
+	public CryptoRSATask(Adaptor adaptor) {
+		super(adaptor);
+		if (adaptor != null) {
+			resourcePath = adaptor.configs.get("resource_dir");
+		}
+	}
+	
+	public String getTaskName() {
+		return "crypto.rsa";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {
+		return new SingleComputeTask();
+	}
+
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {		
+		final static int level = 1;
+
+		PublicKey rsaPub;
+		PrivateKey rsaPriv;
+
+		public byte [] encrypt(byte[] indata, String algorithm) {
+
+			try {
+				Cipher c = Cipher.getInstance(algorithm);
+				byte[] result = indata;
+
+				c.init(Cipher.ENCRYPT_MODE, rsaPub);
+				result = c.doFinal(result);
+
+				return result;
+
+			} catch (Exception e) {
+			}
+
+			return null;
+		}
+
+		public byte[] decrypt(byte[] indata, String algorithm) {
+
+			try {
+				Cipher c = Cipher.getInstance(algorithm);
+
+				byte[] result = indata;
+
+				c.init(Cipher.DECRYPT_MODE, rsaPriv);
+				result = c.doFinal(result);
+
+				return result;
+
+			} catch (Exception e) {
+			}
+
+			return null;
+		}
+
+		public void runSingleEncryptDecrypt(String algorithm, String inputFile) {
+			byte [] indata = Util.getTestData(inputFile);
+			byte [] cipher = encrypt(indata, algorithm);
+			byte [] plain = decrypt(cipher, algorithm);
+			boolean match = Util.check(indata, plain);
+		}
+
+		public void runMultiEncryptDecrypt(String algorithm, String inputFile) {
+			int blockSize = 64;
+			byte [] fullIndata = Util.getTestData(inputFile);
+			byte [] indata = new byte[blockSize];
+			int pass = 0;
+			int fail = 0;
+			int check = 0;
+			for (int i = 0; i + blockSize < fullIndata.length; i+= blockSize) {
+				System.arraycopy(fullIndata, i, indata, 0, blockSize);
+				byte [] cipher = encrypt(indata, algorithm);
+				byte [] plain = decrypt(cipher, algorithm);
+				if (Util.check(indata, plain)) {
+					pass++;
+					check += Util.checkSum(plain);
+				} else {
+					fail++;
+				}
+			}
+		}
+
+		public void setupBenchmark() {
+			try {
+				KeyPairGenerator rsaKeyPairGen = KeyPairGenerator.getInstance("RSA");
+				// 512, 768 and 1024 are commonly used
+				rsaKeyPairGen.initialize(1024);
+
+				KeyPair rsaKeyPair = rsaKeyPairGen.generateKeyPair();
+
+				rsaPub = rsaKeyPair.getPublic();
+				rsaPriv = rsaKeyPair.getPrivate();
+
+			} catch (Exception e) {
+			}
+		}
+		
+		public void realRun() {
+			setupBenchmark();
+			runSingleEncryptDecrypt("RSA/ECB/PKCS1Padding", resourcePath + Util.TEST_DATA_3);
+			runMultiEncryptDecrypt("RSA/ECB/PKCS1Padding", resourcePath + Util.TEST_DATA_5);
+			// Run some more, in order to increase operation workload.
+			runSingleEncryptDecrypt("RSA/ECB/PKCS1Padding", resourcePath + Util.TEST_DATA_3);
+			runMultiEncryptDecrypt("RSA/ECB/PKCS1Padding", resourcePath + Util.TEST_DATA_5);
+			runSingleEncryptDecrypt("RSA/ECB/PKCS1Padding", resourcePath + Util.TEST_DATA_3);
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		CryptoRSATask task = new CryptoRSATask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
+
 }
diff -rupN ./src/org/cloudcmp/tasks/compute/crypto/signverify/CryptoSignverifyTask.java ./src/org/cloudcmp/tasks/compute_full/crypto/signverify/CryptoSignverifyTask.java
--- ./src/org/cloudcmp/tasks/compute/crypto/signverify/CryptoSignverifyTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/crypto/signverify/CryptoSignverifyTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks.crypto.signverify;
+package org.cloudcmp.tasks.compute.crypto.signverify;
 
 import java.io.IOException;
 import java.security.KeyPair;
@@ -13,139 +13,138 @@ import java.security.KeyPairGenerator;
 import java.security.PrivateKey;
 import java.security.PublicKey;
 import java.security.Signature;
+import java.util.Map;
+
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+import org.cloudcmp.tasks.compute.crypto.Util;
+
+public class CryptoSignverifyTask extends ComputeTask {
+	private String resourcePath;
+	
+	public CryptoSignverifyTask(Adaptor adaptor) {
+		super(adaptor);
+		if (adaptor != null) {
+			resourcePath = adaptor.configs.get("resource_dir");
+		}
+	}
+
+	public String getTaskName() {
+		return "crypto.signverify";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {
+		return new SingleComputeTask();
+	}
+	
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		private PublicKey rsaPub;
+		private PrivateKey rsaPriv;
+
+		private PublicKey dsaPub;
+		private PrivateKey dsaPriv;
+
+		private final static int iterations = 10;
+
+		public byte [] sign(byte[] indata, String algorithm, PrivateKey privKey) {
+
+			try {
+				Signature signature = Signature.getInstance(algorithm);
+				signature.initSign(privKey);
+				signature.update(indata);
+				return signature.sign();
+			} catch (Exception e) {
+			}
+
+			return null;
+		}
+
+		public boolean verify(byte[] indata, String algorithm, byte [] signed, PublicKey pubKey) {
+
+			try {
+
+				Signature signature = Signature.getInstance(algorithm);
+				signature.initVerify(pubKey);
+
+				signature.update(indata);
+
+				return signature.verify(signed);
+
+			} catch (Exception e) {
+			}
+
+			return false;
+		}
+
+
+
+		public void runSignVerify(byte[] indata, String algorithm, PrivateKey privKey, PublicKey pubKey) {
+
+			byte [] signed = sign(indata, algorithm, privKey);
+			boolean verification = verify(indata, algorithm, signed, pubKey);
+		}
+
+		public void setupBenchmark() {
+
+			try {
+				KeyPairGenerator rsaKeyPairGen = KeyPairGenerator.getInstance("RSA");
+				// 512, 768 and 1024 are commonly used
+				rsaKeyPairGen.initialize(1024);
+
+				KeyPair rsaKeyPair = rsaKeyPairGen.generateKeyPair();
+
+				rsaPub = rsaKeyPair.getPublic();
+				rsaPriv = rsaKeyPair.getPrivate();
+
+				KeyPairGenerator dsaKeyPairGen = KeyPairGenerator.getInstance("DSA");
+				dsaKeyPairGen.initialize(1024);
+
+				KeyPair dsaKeyPair = dsaKeyPairGen.generateKeyPair();
+
+				dsaPub = dsaKeyPair.getPublic();
+				dsaPriv = dsaKeyPair.getPrivate();
+			} catch (Exception e) {
+			}
+		}
+		
+		public void realRun() {
+			setupBenchmark();
+			for (int i = 0; i < iterations; i++) {
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_4), "MD5withRSA", rsaPriv, rsaPub);
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_4), "SHA1withRSA", rsaPriv, rsaPub);
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_4), "SHA1withDSA", dsaPriv, dsaPub);
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_4), "SHA256withRSA", rsaPriv, rsaPub);
+
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_5), "MD5withRSA", rsaPriv, rsaPub);
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_5), "SHA1withRSA", rsaPriv, rsaPub);
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_5), "SHA1withDSA", dsaPriv, dsaPub);
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_5), "SHA256withRSA", rsaPriv, rsaPub);
+
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_6), "MD5withRSA", rsaPriv, rsaPub);
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_6), "SHA1withRSA", rsaPriv, rsaPub);
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_6), "SHA1withDSA", dsaPriv, dsaPub);
+				runSignVerify(Util.getTestData(resourcePath + Util.TEST_DATA_6), "SHA256withRSA", rsaPriv, rsaPub);
+			}
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		CryptoSignverifyTask task = new CryptoSignverifyTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
 
-import spec.benchmarks.crypto.Util;
-import spec.harness.Context;
-import spec.harness.SpecJVMBenchmarkBase;
-import spec.harness.StopBenchmarkException;
-import spec.harness.results.BenchmarkResult;
-
-public class Main extends SpecJVMBenchmarkBase {
-    
-    private static PublicKey rsaPub;
-    private static PrivateKey rsaPriv;
-    
-    private static PublicKey dsaPub;
-    private static PrivateKey dsaPriv;
-    
-    private final static int iterations = 10;
-    
-    public Main(BenchmarkResult bmResult, int threadId) {
-        super(bmResult, threadId);
-    }
-    
-    /** Run this in multi mode, next to each other. */
-    public static String testType() {
-        return MULTI;
-    }
-    
-    public byte [] sign(byte[] indata, String algorithm, PrivateKey privKey) {
-        
-        try {
-            Signature signature = Signature.getInstance(algorithm);
-            signature.initSign(privKey);
-            signature.update(indata);
-            return signature.sign();
-        } catch (Exception e) {
-            throw new StopBenchmarkException("Exception in verify for " + algorithm + ".", e);
-        }
-    }
-    
-    public boolean verify(byte[] indata, String algorithm, byte [] signed, PublicKey pubKey) {
-        
-        try {
-            
-            Signature signature = Signature.getInstance(algorithm);
-            signature.initVerify(pubKey);
-            
-            signature.update(indata);
-            
-            return signature.verify(signed);
-            
-        } catch (Exception e) {
-            throw new StopBenchmarkException("Exception in verify for " + algorithm + ".", e);
-        }
-    }
-    
-    
-    
-    public void runSignVerify(byte[] indata, String algorithm, PrivateKey privKey, PublicKey pubKey) {
-        
-        byte [] signed = sign(indata, algorithm, privKey);
-        boolean verification = verify(indata, algorithm, signed, pubKey);
-        
-        if (verification) {
-            spec.harness.Context.getOut().println(algorithm + " Verification PASS");
-        } else {
-            spec.harness.Context.getOut().println(algorithm + " Verification FAILED.");
-        }
-        
-    }
-    
-    public void harnessMain() {
-        for (int i = 0; i < iterations; i++) {
-            Context.getOut().println("Iteration " + i + ".");
-            runSignVerify(Util.getTestData(Util.TEST_DATA_4), "MD5withRSA", rsaPriv, rsaPub);
-            runSignVerify(Util.getTestData(Util.TEST_DATA_4), "SHA1withRSA", rsaPriv, rsaPub);
-            runSignVerify(Util.getTestData(Util.TEST_DATA_4), "SHA1withDSA", dsaPriv, dsaPub);
-            runSignVerify(Util.getTestData(Util.TEST_DATA_4), "SHA256withRSA", rsaPriv, rsaPub);
-            
-            runSignVerify(Util.getTestData(Util.TEST_DATA_5), "MD5withRSA", rsaPriv, rsaPub);
-            runSignVerify(Util.getTestData(Util.TEST_DATA_5), "SHA1withRSA", rsaPriv, rsaPub);
-            runSignVerify(Util.getTestData(Util.TEST_DATA_5), "SHA1withDSA", dsaPriv, dsaPub);
-            runSignVerify(Util.getTestData(Util.TEST_DATA_5), "SHA256withRSA", rsaPriv, rsaPub);
-            
-            runSignVerify(Util.getTestData(Util.TEST_DATA_6), "MD5withRSA", rsaPriv, rsaPub);
-            runSignVerify(Util.getTestData(Util.TEST_DATA_6), "SHA1withRSA", rsaPriv, rsaPub);
-            runSignVerify(Util.getTestData(Util.TEST_DATA_6), "SHA1withDSA", dsaPriv, dsaPub);
-            runSignVerify(Util.getTestData(Util.TEST_DATA_6), "SHA256withRSA", rsaPriv, rsaPub);
-        }
-    }
-    
-    public static void setupBenchmark() {
-        
-        try {
-            Context.getFileCache().loadFile(Util.TEST_DATA_4);
-            Context.getFileCache().loadFile(Util.TEST_DATA_5);
-            Context.getFileCache().loadFile(Util.TEST_DATA_6);
-            
-            KeyPairGenerator rsaKeyPairGen = KeyPairGenerator.getInstance("RSA");
-            // 512, 768 and 1024 are commonly used
-            rsaKeyPairGen.initialize(1024);
-            
-            KeyPair rsaKeyPair = rsaKeyPairGen.generateKeyPair();
-            
-            rsaPub = rsaKeyPair.getPublic();
-            rsaPriv = rsaKeyPair.getPrivate();
-            
-            KeyPairGenerator dsaKeyPairGen = KeyPairGenerator.getInstance("DSA");
-            dsaKeyPairGen.initialize(1024);
-            
-            KeyPair dsaKeyPair = dsaKeyPairGen.generateKeyPair();
-            
-            dsaPub = dsaKeyPair.getPublic();
-            dsaPriv = dsaKeyPair.getPrivate();
-        } catch (Exception e) {
-            throw new StopBenchmarkException("Error in setup of crypto.aes." + e);
-        }
-    }
-    
-    public static void createTestData() throws IOException {
-        Util.createRandomTestData(Util.TEST_DATA_4, 1024);
-        Util.createRandomTestData(Util.TEST_DATA_5, 16384);
-        Util.createRandomTestData(Util.TEST_DATA_6, 1048576);
-    }
-    
-    public static void main(String[] args) throws Exception {
-        
-        // createTestData();
-        
-        runSimple(Main.class, args);
-        
-        //setupBenchmark();
-        //Main m = new Main(new BenchmarkResult(), 0);
-        //m.harnessMain();
-        
-    }
-    
 }
diff -rupN ./src/org/cloudcmp/tasks/compute/crypto/Util.java ./src/org/cloudcmp/tasks/compute_full/crypto/Util.java
--- ./src/org/cloudcmp/tasks/compute/crypto/Util.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/crypto/Util.java	2011-11-16 17:05:00.000000000 -0500
@@ -1,25 +1,18 @@
-package spec.benchmarks.crypto;
+package org.cloudcmp.tasks.compute.crypto;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.FileInputStream;
 import java.security.SecureRandom;
 
-import spec.harness.Context;
-import spec.harness.StopBenchmarkException;
-
 public class Util {
     
     private final static boolean DEBUG = false;
     
-    public final static String TEST_DATA_BASE =
-            Context.getSpecBasePath()
-            + File.separator
-            + "resources"
-            + File.separator
-            + "crypto"
-            + File.separator;
+    public final static String TEST_DATA_BASE = File.separator + "crypto" + File.separator;
     
     public final static String TEST_DATA_1 =
             TEST_DATA_BASE + "fredmans21.txt";
@@ -45,26 +38,28 @@ public class Util {
      * @return An byte buffer with the test data.
      */
     public final static byte [] getTestData(String name) {
-        
-        try {
-            int length = Context.getFileCache().getLength(name);
-            length -= length % 16; // align length to avoid padding indata...
-            byte[] testData = new byte[length];
-            ByteArrayInputStream bais = Context.getFileCache().getStream(name);
-            
-            int counter = 0;
-            int bytes_read = 0;
-            do {
-                bytes_read = bais.read(testData, counter, 16);
-                counter += bytes_read;
-            } while (counter + 16 <= length);
-            
-            return testData;
-        } catch (IOException ioe) {
-            throw new StopBenchmarkException("Error getting input stream for file " + name, ioe);
-        }
+	    try {
+		    File f = new File(name);
+		    InputStream is = new FileInputStream(f);
+
+		    int length = (int)(f.length());
+		    length -= length % 16; // align length to avoid padding indata...
+		    byte[] testData = new byte[length];
+
+		    int counter = 0;
+		    int bytes_read = 0;
+		    do {
+			    bytes_read = is.read(testData, counter, length - counter);
+			    counter += bytes_read;
+		    } while (counter + 16 <= length);
+		    return testData;
+	    }
+	    catch (IOException ioe) {}
+	    return null;
     }
     
+    /* ANG: this cannot be done on GAE */
+    /*
     public static void createRandomTestData(String fileName, int length) throws IOException {
         SecureRandom random = new SecureRandom();
         byte [] testData = new byte[length];
@@ -74,6 +69,7 @@ public class Util {
         fos.write(testData);
         fos.close();
     }
+    */
     
     public final static int checkSum(byte [] arr) {
         byte sum = 0;
diff -rupN ./src/org/cloudcmp/tasks/compute/mpegaudio/MpegaudioTask.java ./src/org/cloudcmp/tasks/compute_full/mpegaudio/MpegaudioTask.java
--- ./src/org/cloudcmp/tasks/compute/mpegaudio/MpegaudioTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/mpegaudio/MpegaudioTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -1,45 +1,109 @@
-/*
- * Copyright (c) 2008 Standard Performance Evaluation Corporation (SPEC)
- *               All rights reserved.
- *
- * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
- *
- * This source code is provided as is, without any express or implied warranty.
- */
-package spec.benchmarks.mpegaudio;
-
-import spec.harness.Context;
-import spec.harness.SpecJVMBenchmarkBase;
-import spec.harness.results.BenchmarkResult;
-
-public class Main extends SpecJVMBenchmarkBase {
-    
-    public static final String prefix = Context.getSpecBasePath() + "/resources/mpegaudio/input/";
-    
-    /** Run this in multi mode, next to each other. */
-    public static String testType() {
-        return MULTI;
-    }
-    
-    static long runBenchmark(int btid) {
-        long startTime = System.currentTimeMillis();
-        try {
-            new Harness().inst_main(btid);
-        } catch (Exception e) {
-            e.printStackTrace(Context.getOut());
-        }
-        return System.currentTimeMillis() - startTime;
-    }
-    
-    public Main(BenchmarkResult bmResult, int threadId) {
-        super(bmResult, threadId);
-    }
-    
-    public static void main(String[] args) {
-        runSimple(Main.class, args);
-    }
-    
-    public void harnessMain() {
-        runBenchmark(super.getThreadId());
-    }
-}
+/*
+ * Copyright (c) 2008 Standard Performance Evaluation Corporation (SPEC)
+ *               All rights reserved.
+ *
+ * Copyright (c) 1997,1998 Sun Microsystems, Inc. All rights reserved.
+ *
+ * This source code is provided as is, without any express or implied warranty.
+ */
+package org.cloudcmp.tasks.compute.mpegaudio;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.util.Map;
+import java.util.zip.CRC32;
+
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+
+import javazoom.jl.decoder.Bitstream;
+import javazoom.jl.decoder.BitstreamException;
+import javazoom.jl.decoder.Decoder;
+import javazoom.jl.decoder.DecoderException;
+import javazoom.jl.decoder.Header;
+import javazoom.jl.decoder.SampleBuffer;
+
+public class MpegaudioTask extends ComputeTask {	
+	public MpegaudioTask(Adaptor adaptor) {
+		super(adaptor);
+		// TODO Auto-generated constructor stub
+	}
+
+	public String getTaskName() {
+		return "mpegaudio";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {
+		return new SingleComputeTask();
+	}	
+
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		static final int TRACKS_NUMBER = 6;
+		static final int FRAMES_LIMIT = 8000;
+
+		long[] result = new long[TRACKS_NUMBER];
+
+		private String getName(int index) {
+			return adaptor.configs.get("resource_dir") + "/mpegaudio/input/track" + index + ".mp3";
+		}
+		
+		public void realRun() {
+			try {
+				for (int i = 0; i < TRACKS_NUMBER; i++) {
+					int ind = i % TRACKS_NUMBER;
+					result[ind] = decode(getName(ind));
+				}
+			} catch (Exception e) {
+			}
+		}
+		
+
+		private void updateCRC32(CRC32 crc32, short[] buffer) {
+			int length = buffer.length;
+			byte[] b = new byte[length * 2];
+			for (int i = 0; i < length; i++) {
+				short value = buffer[i];
+				b[i] = (byte) buffer[i];
+				b[i + length] = (byte) ((value & 0xff00) >> 8);
+			}
+
+			crc32.update(b, 0, b.length);
+		}
+
+		public long decode(final String name) throws BitstreamException,
+		       DecoderException, FileNotFoundException {
+			       Bitstream stream = new Bitstream(new FileInputStream(name));
+			       Decoder decoder = new Decoder();
+			       Header h;
+			       CRC32 crc = new CRC32();
+			       int decodedFrames = 0;
+			       while (decodedFrames < FRAMES_LIMIT && (h = stream.readFrame()) != null) {
+				       decodedFrames++;
+				       updateCRC32(crc, ((SampleBuffer) decoder.decodeFrame(h, stream))
+						       .getBuffer());
+				       stream.closeFrame();
+			       }
+			       stream.close();
+			       return crc.getValue();
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		MpegaudioTask task = new MpegaudioTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
+}
diff -rupN ./src/org/cloudcmp/tasks/compute/scimark/fft/ScimarkFFTTask.java ./src/org/cloudcmp/tasks/compute_full/scimark/fft/ScimarkFFTTask.java
--- ./src/org/cloudcmp/tasks/compute/scimark/fft/ScimarkFFTTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/scimark/fft/ScimarkFFTTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -6,11 +6,12 @@
  *
  * This source code is provided as is, without any express or implied warranty.
  */
-package spec.benchmarks.scimark.fft;
-import spec.benchmarks.scimark.utils.Constants;
-import spec.benchmarks.scimark.utils.Random;
-import spec.benchmarks.scimark.utils.kernel;
-import spec.benchmarks.scimark.utils.Stopwatch;
+package org.cloudcmp.tasks.compute.scimark.fft;
+import java.util.Map;
+
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+import org.cloudcmp.tasks.compute.scimark.utils.*;
 
 /** Computes FFT's of complex, double precision data where n is an integer power of 2.
  * This appears to be slower than the Radix2 method,
@@ -25,238 +26,253 @@ import spec.benchmarks.scimark.utils.Sto
   /* See {@link ComplexDoubleFFT ComplexDoubleFFT} for details of data layout.
    */
 
-public class FFT {
-    int id;
-    
-    public FFT(int id) {
-        this.id = id;
-    }
-    
-    public  final double num_flops(int N) {
-        double Nd = (double) N;
-        double logN = (double) log2(N);
-        
-        return (5.0*Nd-2)*logN + 2*(Nd+1);
-    }
-    public long inst_main(String[] argv) {
-        run();
-        return 0;
-    }
-    
-    /** Compute Fast Fourier Transform of (complex) data, in place.*/
-    public   void transform(double data[]) {
-        transform_internal(data, -1); }
-    
-    /** Compute Inverse Fast Fourier Transform of (complex) data, in place.*/
-    public   void inverse(double data[]) {
-        transform_internal(data, +1);
-        // Normalize
-        int nd=data.length;
-        int n =nd/2;
-        double norm=1/((double) n);
-        for(int i=0; i<nd; i++)
-            data[i] *= norm;
-    }
-    
-    /** Accuracy check on FFT of data. Make a copy of data, Compute the FFT, then
-     * the inverse and compare to the original.  Returns the rms difference.*/
-    public   double test(double data[]){
-        int nd = data.length;
-        // Make duplicate for comparison
-        double copy[] = new double[nd];
-        System.arraycopy(data,0,copy,0,nd);
-        // Transform & invert
-        transform(data);
-        inverse(data);
-        // Compute RMS difference.
-        double diff = 0.0;
-        for(int i=0; i<nd; i++) {
-            double d = data[i]-copy[i];
-            diff += d*d; }
-        return Math.sqrt(diff/nd); }
-    
-    /** Make a random array of n (complex) elements. */
-    public   double[] makeRandom(int n){
-        int nd = 2*n;
-        double data[] = new double[nd];
-        for(int i=0; i<nd; i++)
-            data[i]= Math.random();
-        return data; }
-    
-    /** Simple Test routine. */
-    public static void main(int id){
-        FFT fft = new FFT(id);
-        fft.run();
-    }
-    /* ______________________________________________________________________ */
-    
-    protected   int log2(int n){
-        int log = 0;
-        for(int k=1; k < n; k *= 2, log++);
-        if (n != (1 << log))
-            throw new Error("FFT: Data length is not a power of 2!: "+n);
-        return log; }
-    
-    protected   void transform_internal(double data[], int direction) {
-        if (data.length == 0) return;
-        int n = data.length/2;
-        if (n == 1) return;         // Identity operation!
-        int logn = log2(n);
-        
-        /* bit reverse the input data for decimation in time algorithm */
-        bitreverse(data) ;
-        
-        /* apply fft recursion */
-        /* this loop executed log2(N) times */
-        for (int bit = 0, dual = 1; bit < logn; bit++, dual *= 2) {
-            double w_real = 1.0;
-            double w_imag = 0.0;
-            
-            double theta = 2.0 * direction * Math.PI / (2.0 * (double) dual);
-            double s = Math.sin(theta);
-            double t = Math.sin(theta / 2.0);
-            double s2 = 2.0 * t * t;
-            
-            /* a = 0 */
-            for (int b = 0; b < n; b += 2 * dual) {
-                int i = 2*b ;
-                int j = 2*(b + dual);
-                
-                double wd_real = data[j] ;
-                double wd_imag = data[j+1] ;
-                
-                data[j]   = data[i]   - wd_real;
-                data[j+1] = data[i+1] - wd_imag;
-                data[i]  += wd_real;
-                data[i+1]+= wd_imag;
-            }
-            
-            /* a = 1 .. (dual-1) */
-            for (int a = 1; a < dual; a++) {
-                /* trignometric recurrence for w-> exp(i theta) w */
-                {
-                    double tmp_real = w_real - s * w_imag - s2 * w_real;
-                    double tmp_imag = w_imag + s * w_real - s2 * w_imag;
-                    w_real = tmp_real;
-                    w_imag = tmp_imag;
-                }
-                for (int b = 0; b < n; b += 2 * dual) {
-                    int i = 2*(b + a);
-                    int j = 2*(b + a + dual);
-                    
-                    double z1_real = data[j];
-                    double z1_imag = data[j+1];
-                    
-                    double wd_real = w_real * z1_real - w_imag * z1_imag;
-                    double wd_imag = w_real * z1_imag + w_imag * z1_real;
-                    
-                    data[j]   = data[i]   - wd_real;
-                    data[j+1] = data[i+1] - wd_imag;
-                    data[i]  += wd_real;
-                    data[i+1]+= wd_imag;
-                }
-            }
-        }
-    }
-    
-    
-    protected   void bitreverse(double data[]) {
-        /* This is the Goldrader bit-reversal algorithm */
-        int n=data.length/2;
-        int nm1 = n-1;
-        int i=0;
-        int j=0;
-        for (; i < nm1; i++) {
-            
-            //int ii = 2*i;
-            int ii = i << 1;
-            
-            //int jj = 2*j;
-            int jj = j << 1;
-            
-            //int k = n / 2 ;
-            int k = n >> 1;
-            
-            if (i < j) {
-                double tmp_real    = data[ii];
-                double tmp_imag    = data[ii+1];
-                data[ii]   = data[jj];
-                data[ii+1] = data[jj+1];
-                data[jj]   = tmp_real;
-                data[jj+1] = tmp_imag; }
-            
-            while (k <= j) {
-                //j = j - k ;
-                j -= k;
-                
-                //k = k / 2 ;
-                k >>= 1 ;
-            }
-            j += k ;
-        }
-    }
-    
-    // ThreadLocal for StringBuilder used to create toString()s
-    private static final ThreadLocal <double[]> threadLocalVector =
-            new ThreadLocal<double[]> () {
-        @Override protected double[] initialValue() {
-            return new double[kernel.CURRENT_FFT_SIZE];
-        }
-    };
-    
-    public  double measureFFT(int N, double mintime, Random R) {
-        
-        // use a ThreadLocal for double array x[]
-        double x[];
-        x = threadLocalVector.get();
-        if(x.length != N){
-            x = new double[N];
-            threadLocalVector.set(x);
-        }
-        // initialize FFT data as complex (N real/img pairs
-        //double x[] = kernel.RandomVector(N * 2, R);
-        x = kernel.RandomizeVector(x, R);
-        // oldx no longer used
-        //double oldx[] = kernel.NewVectorCopy(x);
-        
-        long cycles = 1;
-        Stopwatch Q = new Stopwatch();
-        //FFT fft = new FFT();
-        Q.start();
-        transform(x);	// forward transform
-        inverse(x);		// backward transform
-        Q.stop();
-        
-        final double EPS = 1.0e-10;
-        double fftTest = test(x);
-        kernel.checkResults(kernel.CURRENT_FFT_RESULT, "" + fftTest, id);
-        if ( fftTest / N > EPS )
-            return 0.0;
-        x = null;
-        //oldx = null;
-        return num_flops(N)*cycles/ Q.read() * 1.0e-6;
-    }
-    public void run() {
-        try{
-            double min_time = Constants.RESOLUTION_DEFAULT;
-            int FFT_size = kernel.CURRENT_FFT_SIZE;
-            // run the benchmark
-            double res = 0.0;
-            Random R = new Random(Constants.RANDOM_SEED);
-            res = measureFFT( FFT_size, min_time, R);
-        } catch(Exception e){
-            e.printStackTrace();
-        }
-        
-        
-        
-        
-    }
-}
+public class ScimarkFFTTask extends ComputeTask {
+	public ScimarkFFTTask(Adaptor adaptor) {
+		super(adaptor);
+		// TODO Auto-generated constructor stub
+	}
+	
+	public String getTaskName() {
+		return "scimark.fft";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {
+		return new SingleComputeTask();
+	}
+	
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		int id = 0;
+
+		public  final double num_flops(int N) {
+			double Nd = (double) N;
+			double logN = (double) log2(N);
+
+			return (5.0*Nd-2)*logN + 2*(Nd+1);
+		}
+
+		/** Compute Fast Fourier Transform of (complex) data, in place.*/
+		public   void transform(double data[]) {
+			transform_internal(data, -1); }
+
+		/** Compute Inverse Fast Fourier Transform of (complex) data, in place.*/
+		public   void inverse(double data[]) {
+			transform_internal(data, +1);
+			// Normalize
+			int nd=data.length;
+			int n =nd/2;
+			double norm=1/((double) n);
+			for(int i=0; i<nd; i++)
+				data[i] *= norm;
+		}
+
+		/** Accuracy check on FFT of data. Make a copy of data, Compute the FFT, then
+		 * the inverse and compare to the original.  Returns the rms difference.*/
+		public   double test(double data[]){
+			int nd = data.length;
+			// Make duplicate for comparison
+			double copy[] = new double[nd];
+			System.arraycopy(data,0,copy,0,nd);
+			// Transform & invert
+			transform(data);
+			inverse(data);
+			// Compute RMS difference.
+			double diff = 0.0;
+			for(int i=0; i<nd; i++) {
+				double d = data[i]-copy[i];
+				diff += d*d; 
+			}
+			return Math.sqrt(diff/nd); 
+		}
+
+		/** Make a random array of n (complex) elements. */
+		public   double[] makeRandom(int n){
+			int nd = 2*n;
+			double data[] = new double[nd];
+			for(int i=0; i<nd; i++)
+				data[i]= Math.random();
+			return data; 
+		}
+
+		protected   int log2(int n){
+			int log = 0;
+			for(int k=1; k < n; k *= 2, log++);
+			if (n != (1 << log))
+				throw new Error("FFT: Data length is not a power of 2!: "+n);
+			return log; 
+		}
+
+		protected   void transform_internal(double data[], int direction) {
+			if (data.length == 0) return;
+			int n = data.length/2;
+			if (n == 1) return;         // Identity operation!
+			int logn = log2(n);
+
+			/* bit reverse the input data for decimation in time algorithm */
+			bitreverse(data) ;
+
+			/* apply fft recursion */
+			/* this loop executed log2(N) times */
+			for (int bit = 0, dual = 1; bit < logn; bit++, dual *= 2) {
+				double w_real = 1.0;
+				double w_imag = 0.0;
+
+				double theta = 2.0 * direction * Math.PI / (2.0 * (double) dual);
+				double s = Math.sin(theta);
+				double t = Math.sin(theta / 2.0);
+				double s2 = 2.0 * t * t;
+
+				/* a = 0 */
+				for (int b = 0; b < n; b += 2 * dual) {
+					int i = 2*b ;
+					int j = 2*(b + dual);
+
+					double wd_real = data[j] ;
+					double wd_imag = data[j+1] ;
 
+					data[j]   = data[i]   - wd_real;
+					data[j+1] = data[i+1] - wd_imag;
+					data[i]  += wd_real;
+					data[i+1]+= wd_imag;
+				}
 
+				/* a = 1 .. (dual-1) */
+				for (int a = 1; a < dual; a++) {
+					/* trignometric recurrence for w-> exp(i theta) w */
+					{
+						double tmp_real = w_real - s * w_imag - s2 * w_real;
+						double tmp_imag = w_imag + s * w_real - s2 * w_imag;
+						w_real = tmp_real;
+						w_imag = tmp_imag;
+					}
+					for (int b = 0; b < n; b += 2 * dual) {
+						int i = 2*(b + a);
+						int j = 2*(b + a + dual);
 
+						double z1_real = data[j];
+						double z1_imag = data[j+1];
 
+						double wd_real = w_real * z1_real - w_imag * z1_imag;
+						double wd_imag = w_real * z1_imag + w_imag * z1_real;
+
+						data[j]   = data[i]   - wd_real;
+						data[j+1] = data[i+1] - wd_imag;
+						data[i]  += wd_real;
+						data[i+1]+= wd_imag;
+					}
+				}
+			}
+		}
+
+
+		protected   void bitreverse(double data[]) {
+			/* This is the Goldrader bit-reversal algorithm */
+			int n=data.length/2;
+			int nm1 = n-1;
+			int i=0;
+			int j=0;
+			for (; i < nm1; i++) {
+
+				//int ii = 2*i;
+				int ii = i << 1;
+
+				//int jj = 2*j;
+				int jj = j << 1;
+
+				//int k = n / 2 ;
+				int k = n >> 1;
+
+				if (i < j) {
+					double tmp_real    = data[ii];
+					double tmp_imag    = data[ii+1];
+					data[ii]   = data[jj];
+					data[ii+1] = data[jj+1];
+					data[jj]   = tmp_real;
+					data[jj+1] = tmp_imag; }
+
+					while (k <= j) {
+						//j = j - k ;
+						j -= k;
+
+						//k = k / 2 ;
+						k >>= 1 ;
+					}
+					j += k ;
+			}
+		}
+		
+		private double x[] = new double[kernel.CURRENT_FFT_SIZE];
+
+//		// ThreadLocal for StringBuilder used to create toString()s
+//		private static final ThreadLocal <double[]> threadLocalVector =
+//			new ThreadLocal<double[]> () {
+//				@Override protected double[] initialValue() {
+//					return new double[kernel.CURRENT_FFT_SIZE];
+//				}
+//			};
+
+		public  double measureFFT(int N, double mintime, Random R) {			
+			if(x.length != N){
+				x = new double[N];				
+			}
+			// initialize FFT data as complex (N real/img pairs
+			//double x[] = kernel.RandomVector(N * 2, R);
+			x = kernel.RandomizeVector(x, R);
+			// oldx no longer used
+			//double oldx[] = kernel.NewVectorCopy(x);
+
+			long cycles = 1;
+			Stopwatch Q = new Stopwatch();
+			//FFT fft = new FFT();
+			Q.start();
+			transform(x);	// forward transform
+			inverse(x);		// backward transform
+			Q.stop();
+
+			final double EPS = 1.0e-10;
+			double fftTest = test(x);
+			kernel.checkResults(kernel.CURRENT_FFT_RESULT, "" + fftTest, id);
+			if ( fftTest / N > EPS )
+				return 0.0;
+			x = null;
+			//oldx = null;
+			return num_flops(N)*cycles/ Q.read() * 1.0e-6;
+		}
+		
+		public void realRun() {
+			kernel.init();
+
+			try{
+				double min_time = Constants.RESOLUTION_DEFAULT;
+				int FFT_size = kernel.CURRENT_FFT_SIZE;
+				// run the benchmark
+				double res = 0.0;
+				Random R = new Random(Constants.RANDOM_SEED);
+				res = measureFFT( FFT_size, min_time, R);
+			} catch(Exception e){
+				e.printStackTrace();
+			}
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		ScimarkFFTTask task = new ScimarkFFTTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
+}
 
 
 
diff -rupN ./src/org/cloudcmp/tasks/compute/scimark/lu/ScimarkLUTask.java ./src/org/cloudcmp/tasks/compute_full/scimark/lu/ScimarkLUTask.java
--- ./src/org/cloudcmp/tasks/compute/scimark/lu/ScimarkLUTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/scimark/lu/ScimarkLUTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -6,12 +6,13 @@
  *
  * This source code is provided as is, without any express or implied warranty.
  */
-package spec.benchmarks.scimark.lu;
+package org.cloudcmp.tasks.compute.scimark.lu;
 
-import spec.benchmarks.scimark.utils.Constants;
-import spec.benchmarks.scimark.utils.Random;
-import spec.benchmarks.scimark.utils.Stopwatch;
-import spec.benchmarks.scimark.utils.kernel;
+import java.util.Map;
+
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+import org.cloudcmp.tasks.compute.scimark.utils.*;
 
 /**
  * LU matrix factorization. (Based on TNT implementation.)
@@ -22,27 +23,20 @@ import spec.benchmarks.scimark.utils.ker
  * a NxN matrix.
  *
  */
-public class LU {
-    int id;
-    
-    public LU(int id) {
-        this.id = id;
-    }
-    
-    /**
-     * Returns a <em>copy</em> of the compact LU factorization.
-     * (useful mainly for debugging.)
-     *
-     * Retrieves the compact LU factorization. The U factor
-     * is stored in the upper triangular portion, and the L
-     * factor is stored in the lower triangular portion.
-     * The main diagonal of L consists (by convention) of
-     * ones, and is not explicitly stored.
-     */
-    public static void main(int id) {
-        LU lu = new LU(id);
-        lu.run();
-    }
+public class ScimarkLUTask extends ComputeTask {
+	public ScimarkLUTask(Adaptor adaptor) {
+		super(adaptor);
+		// TODO Auto-generated constructor stub
+	}
+
+	public String getTaskName() {
+		return "scimark.lu";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {
+		return new SingleComputeTask();
+	}
+
     
     public static final double num_flops(int N) {
         // rougly 2/3*N^3
@@ -107,230 +101,266 @@ public class LU {
         }
         
     }
-    public double[][] getLU() {
-        return new_copy(LU_);
-    }
-    
-    /**
-     * Returns a <em>copy</em> of the pivot vector.
-     *
-     * @return the pivot vector used in obtaining the
-     * LU factorzation.  Subsequent solutions must
-     * permute the right-hand side by this vector.
-     *
-     */
-    public int[] getPivot() {
-        return new_copy(pivot_);
-    }
-    
-    /**
-     * Initalize LU factorization from matrix.
-     *
-     * @param A (in) the matrix to associate with this
-     * factorization.
-     */
-   /* public LU( double A[][] )
-    {
-        int M = A.length;
-        int N = A[0].length;
-    
-        //if ( LU_ == null || LU_.length != M || LU_[0].length != N)
-            LU_ = new double[M][N];
-    
-        insert_copy(LU_, A);
-    
-        //if (pivot_.length != M)
-            pivot_ = new int[M];
-    
-        factor(LU_, pivot_);
-    }*/
-    
-    /**
-     * Solve a linear system, with pre-computed factorization.
-     *
-     * @param b (in) the right-hand side.
-     * @return solution vector.
-     */
-    public double[] solve(double b[]) {
-        double x[] = new_copy(b);
-        
-        solve(LU_, pivot_, x);
-        return x;
-    }
-    
-    
-    /**
-     * LU factorization (in place).
-     *
-     * @param A (in/out) On input, the matrix to be factored.
-     * On output, the compact LU factorization.
-     *
-     * @param pivot (out) The pivot vector records the
-     * reordering of the rows of A during factorization.
-     *
-     * @return 0, if OK, nozero value, othewise.
-     */
-    public int factor(double A[][],  int pivot[]) {
-        
-        int N = A.length;
-        int M = A[0].length;
-        
-        int minMN = Math.min(M,N);
-        
-        for (int j=0; j<minMN; j++) {
-            // find pivot in column j and  test for singularity.
-            
-            int jp=j;
-            
-            double t = Math.abs(A[j][j]);
-            for (int i=j+1; i<M; i++) {
-                double ab = Math.abs(A[i][j]);
-                if ( ab > t) {
-                    jp = i;
-                    t = ab;
-                }
-            }
-            
-            pivot[j] = jp;
-            
-            // jp now has the index of maximum element
-            // of column j, below the diagonal
-            
-            if ( A[jp][j] == 0 )
-                return 1;       // factorization failed because of zero pivot
-            
-            
-            if (jp != j) {
-                // swap rows j and jp
-                double tA[] = A[j];
-                A[j] = A[jp];
-                A[jp] = tA;
-            }
-            
-            if (j<M-1)                // compute elements j+1:M of jth column
-            {
-                // note A(j,j), was A(jp,p) previously which was
-                // guarranteed not to be zero (Label #1)
-                //
-                double recp =  1.0 / A[j][j];
-                
-                for (int k=j+1; k<M; k++)
-                    A[k][j] *= recp;
-            }
-            
-            
-            if (j < minMN-1) {
-                // rank-1 update to trailing submatrix:   E = E - x*y;
-                //
-                // E is the region A(j+1:M, j+1:N)
-                // x is the column vector A(j+1:M,j)
-                // y is row vector A(j,j+1:N)
-                
-                
-                for (int ii=j+1; ii<M; ii++) {
-                    double Aii[] = A[ii];
-                    double Aj[] = A[j];
-                    double AiiJ = Aii[j];
-                    for (int jj=j+1; jj<N; jj++)
-                        Aii[jj] -= AiiJ * Aj[jj];
-                    
-                }
-            }
-        }
-        
-        return 0;
-    }
-    
-    
-    /**
-     * Solve a linear system, using a prefactored matrix
-     * in LU form.
-     *
-     * @param LU (in) the factored matrix in LU form.
-     * @param pvt (in) the pivot vector which lists
-     * the reordering used during the factorization
-     * stage.
-     * @param b    (in/out) On input, the right-hand side.
-     * On output, the solution vector.
-     */
-    public void solve(double LU[][], int pvt[], double b[]) {
-        int M = LU.length;
-        int N = LU[0].length;
-        int ii=0;
-        
-        for (int i=0; i<M; i++) {
-            int ip = pvt[i];
-            double sum = b[ip];
-            
-            b[ip] = b[i];
-            if (ii==0)
-                for (int j=ii; j<i; j++)
-                    sum -= LU[i][j] * b[j];
-            else
-                if (sum == 0.0)
-                    ii = i;
-            b[i] = sum;
-        }
-        
-        for (int i=N-1; i>=0; i--) {
-            double sum = b[i];
-            for (int j=i+1; j<N; j++)
-                sum -= LU[i][j] * b[j];
-            b[i] = sum / LU[i][i];
-        }
-    }
-    
-    
-    private double LU_[][];
-    private int pivot_[];
-    
-    public double measureLU(int N, double min_time, Random R) {
-        // compute approx Mlfops, or O if LU yields large errors
-        double A[][] = kernel.RandomMatrix(N, N,  R);
-        double lu[][] = new double[N][N];
-        int pivot[] = new int[N];
-        
-        Stopwatch Q = new Stopwatch();
-        
-        int cycles=2;
-        //while(true)
-        //{
-        Q.start();
-        for (int i=0; i<cycles; i++) {
-            kernel.CopyMatrix(lu, A);
-            factor(lu, pivot);
-        }
-        Q.stop();
-        //	if (Q.read() >= min_time) break;
-        
-        
-        // verify that LU is correct
-        double b[] = kernel.RandomVector(N, R);
-        double x[] = kernel.NewVectorCopy(b);
-        
-        solve(lu, pivot, x);
-        
-        final double EPS = 1.0e-12;
-        kernel.checkResults(kernel.CURRENT_LU_RESULT,
-                "" +  kernel.normabs(b, kernel.matvec(A,x)), id);
-        
-        if ( kernel.normabs(b, kernel.matvec(A,x)) / N > EPS )
-            return 0.0;
-        
-        
-        // else return approx Mflops
-        //
-        return LU.num_flops(N) * cycles / Q.read() * 1.0e-6;
-    }
-    
-    public void run() {
-        
-        double min_time = Constants.RESOLUTION_DEFAULT;
-        int LU_size = kernel.CURRENT_LU_SIZE;
-        // run the benchmark
-        
-        double res = 0.0;
-        Random R = new Random(Constants.RANDOM_SEED);
-        res = measureLU( LU_size, min_time, R);
-    }
+
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		int id = 0;
+	    
+	    /**
+	     * Returns a <em>copy</em> of the compact LU factorization.
+	     * (useful mainly for debugging.)
+	     *
+	     * Retrieves the compact LU factorization. The U factor
+	     * is stored in the upper triangular portion, and the L
+	     * factor is stored in the lower triangular portion.
+	     * The main diagonal of L consists (by convention) of
+	     * ones, and is not explicitly stored.
+	     */
+
+	    public double[][] getLU() {
+	        return new_copy(LU_);
+	    }
+	    
+	    /**
+	     * Returns a <em>copy</em> of the pivot vector.
+	     *
+	     * @return the pivot vector used in obtaining the
+	     * LU factorzation.  Subsequent solutions must
+	     * permute the right-hand side by this vector.
+	     *
+	     */
+	    public int[] getPivot() {
+	        return new_copy(pivot_);
+	    }
+	    
+	    /**
+	     * Initalize LU factorization from matrix.
+	     *
+	     * @param A (in) the matrix to associate with this
+	     * factorization.
+	     */
+	   /* public LU( double A[][] )
+	    {
+	        int M = A.length;
+	        int N = A[0].length;
+	    
+	        //if ( LU_ == null || LU_.length != M || LU_[0].length != N)
+	            LU_ = new double[M][N];
+	    
+	        insert_copy(LU_, A);
+	    
+	        //if (pivot_.length != M)
+	            pivot_ = new int[M];
+	    
+	        factor(LU_, pivot_);
+	    }*/
+	    
+	    /**
+	     * Solve a linear system, with pre-computed factorization.
+	     *
+	     * @param b (in) the right-hand side.
+	     * @return solution vector.
+	     */
+	    public double[] solve(double b[]) {
+	        double x[] = new_copy(b);
+	        
+	        solve(LU_, pivot_, x);
+	        return x;
+	    }
+	    
+	    
+	    /**
+	     * LU factorization (in place).
+	     *
+	     * @param A (in/out) On input, the matrix to be factored.
+	     * On output, the compact LU factorization.
+	     *
+	     * @param pivot (out) The pivot vector records the
+	     * reordering of the rows of A during factorization.
+	     *
+	     * @return 0, if OK, nozero value, othewise.
+	     */
+	    public int factor(double A[][],  int pivot[]) {
+	        
+	        int N = A.length;
+	        int M = A[0].length;
+	        
+	        int minMN = Math.min(M,N);
+	        
+	        for (int j=0; j<minMN; j++) {
+	            // find pivot in column j and  test for singularity.
+	            
+	            int jp=j;
+	            
+	            double t = Math.abs(A[j][j]);
+	            for (int i=j+1; i<M; i++) {
+	                double ab = Math.abs(A[i][j]);
+	                if ( ab > t) {
+	                    jp = i;
+	                    t = ab;
+	                }
+	            }
+	            
+	            pivot[j] = jp;
+	            
+	            // jp now has the index of maximum element
+	            // of column j, below the diagonal
+	            
+	            if ( A[jp][j] == 0 )
+	                return 1;       // factorization failed because of zero pivot
+	            
+	            
+	            if (jp != j) {
+	                // swap rows j and jp
+	                double tA[] = A[j];
+	                A[j] = A[jp];
+	                A[jp] = tA;
+	            }
+	            
+	            if (j<M-1)                // compute elements j+1:M of jth column
+	            {
+	                // note A(j,j), was A(jp,p) previously which was
+	                // guarranteed not to be zero (Label #1)
+	                //
+	                double recp =  1.0 / A[j][j];
+	                
+	                for (int k=j+1; k<M; k++)
+	                    A[k][j] *= recp;
+	            }
+	            
+	            
+	            if (j < minMN-1) {
+	                // rank-1 update to trailing submatrix:   E = E - x*y;
+	                //
+	                // E is the region A(j+1:M, j+1:N)
+	                // x is the column vector A(j+1:M,j)
+	                // y is row vector A(j,j+1:N)
+	                
+	                
+	                for (int ii=j+1; ii<M; ii++) {
+	                    double Aii[] = A[ii];
+	                    double Aj[] = A[j];
+	                    double AiiJ = Aii[j];
+	                    for (int jj=j+1; jj<N; jj++)
+	                        Aii[jj] -= AiiJ * Aj[jj];
+	                    
+	                }
+	            }
+	        }
+	        
+	        return 0;
+	    }
+	    
+	    
+	    /**
+	     * Solve a linear system, using a prefactored matrix
+	     * in LU form.
+	     *
+	     * @param LU (in) the factored matrix in LU form.
+	     * @param pvt (in) the pivot vector which lists
+	     * the reordering used during the factorization
+	     * stage.
+	     * @param b    (in/out) On input, the right-hand side.
+	     * On output, the solution vector.
+	     */
+	    public void solve(double LU[][], int pvt[], double b[]) {
+	        int M = LU.length;
+	        int N = LU[0].length;
+	        int ii=0;
+	        
+	        for (int i=0; i<M; i++) {
+	            int ip = pvt[i];
+	            double sum = b[ip];
+	            
+	            b[ip] = b[i];
+	            if (ii==0)
+	                for (int j=ii; j<i; j++)
+	                    sum -= LU[i][j] * b[j];
+	            else
+	                if (sum == 0.0)
+	                    ii = i;
+	            b[i] = sum;
+	        }
+	        
+	        for (int i=N-1; i>=0; i--) {
+	            double sum = b[i];
+	            for (int j=i+1; j<N; j++)
+	                sum -= LU[i][j] * b[j];
+	            b[i] = sum / LU[i][i];
+	        }
+	    }
+	    
+	    
+	    private double LU_[][];
+	    private int pivot_[];
+	    
+	    public double measureLU(int N, double min_time, Random R) {
+	        // compute approx Mlfops, or O if LU yields large errors
+	        double A[][] = kernel.RandomMatrix(N, N,  R);
+	        double lu[][] = new double[N][N];
+	        int pivot[] = new int[N];
+	        
+	        Stopwatch Q = new Stopwatch();
+	        
+	        int cycles=2;
+	        //while(true)
+	        //{
+	        Q.start();
+	        for (int i=0; i<cycles; i++) {
+	            kernel.CopyMatrix(lu, A);
+	            factor(lu, pivot);
+	        }
+	        Q.stop();
+	        //	if (Q.read() >= min_time) break;
+	        
+	        
+	        // verify that LU is correct
+	        double b[] = kernel.RandomVector(N, R);
+	        double x[] = kernel.NewVectorCopy(b);
+	        
+	        solve(lu, pivot, x);
+	        
+	        final double EPS = 1.0e-12;
+	        kernel.checkResults(kernel.CURRENT_LU_RESULT,
+	                "" +  kernel.normabs(b, kernel.matvec(A,x)), id);
+	        
+	        if ( kernel.normabs(b, kernel.matvec(A,x)) / N > EPS )
+	            return 0.0;
+	        
+	        
+	        // else return approx Mflops
+	        //
+	        return ScimarkLUTask.num_flops(N) * cycles / Q.read() * 1.0e-6;
+	    }
+	    
+		public void realRun() {
+		    kernel.init();
+
+		    double min_time = Constants.RESOLUTION_DEFAULT;
+		    int LU_size = kernel.CURRENT_LU_SIZE;
+		    // run the benchmark
+
+		    double res = 0.0;
+		    Random R = new Random(Constants.RANDOM_SEED);
+		    res = measureLU( LU_size, min_time, R);
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		ScimarkLUTask task = new ScimarkLUTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
 }
diff -rupN ./src/org/cloudcmp/tasks/compute/scimark/monte_carlo/ScimarkMonteCarloTask.java ./src/org/cloudcmp/tasks/compute_full/scimark/monte_carlo/ScimarkMonteCarloTask.java
--- ./src/org/cloudcmp/tasks/compute/scimark/monte_carlo/ScimarkMonteCarloTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/scimark/monte_carlo/ScimarkMonteCarloTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -7,11 +7,14 @@
  * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks.scimark.monte_carlo;
+package org.cloudcmp.tasks.compute.scimark.monte_carlo;
 import java.io.PrintStream;
-import spec.benchmarks.scimark.utils.Constants;
-import spec.benchmarks.scimark.utils.Random;
-import spec.benchmarks.scimark.utils.Stopwatch;
+import java.util.Map;
+
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+import org.cloudcmp.tasks.compute.scimark.lu.ScimarkLUTask;
+import org.cloudcmp.tasks.compute.scimark.utils.*;
 
 /**
  * Estimate Pi by approximating the area of a circle.
@@ -42,73 +45,93 @@ import spec.benchmarks.scimark.utils.Sto
  *
  */
 
-public class MonteCarlo {
-    final static int SEED = 113;
-    
-    public static void main() {
-        MonteCarlo mc = new MonteCarlo();
-        mc.run();
-    }
-    
-    public final double num_flops(int Num_samples) {
-        // 3 flops in x^2+y^2 and 1 flop in random routine
-        
-        return ((double) Num_samples)* 4.0;
-        
-    }
-    
-    
-    
-    public final double integrate(int numSamples) {
-        
-        Random R = new Random(SEED);
-        
-        int underCurve = 0;
-        for (int count = 0; count < numSamples; count++) {
-            
-            double x = R.nextDouble();
-            double y = R.nextDouble();
-            
-            if ( x*x + y*y <= 1.0) {
-                underCurve ++;
-            }
-        }
-        return ((double) underCurve / numSamples) * 4.0;
-    }
-    
-    public double measureMonteCarlo(double min_time, Random R) {
-        PrintStream p = spec.harness.Context.getOut();
-        Stopwatch Q = new Stopwatch();
-        
-        // Cycles set to integrate into SPECjvm2008 benchmark harness.  Testing done on
-        // Apple Macbook Pro 2.0Ghz Intel Core Duo, 1GB 667mhz SODIMM
-        // J2SE 5.0_06 (Apple)
-        // Tuning: -server
-        int cycles=16777216;
-        double x =0.0;
-        
-        Q.start();
-        x = integrate(cycles);
-        Q.stop();
-        
-        p.println(x);
-        return num_flops(cycles) / Q.read() * 1.0e-6;
-    }
-    
-    public void run() {
-        double min_time = Constants.RESOLUTION_DEFAULT;
-        
-        // run the benchmark
-        
-        double res = 0.0;
-        Random R = new Random(Constants.RANDOM_SEED);
-        res = measureMonteCarlo(min_time, R);
-        
-        
-        
-        
-    }
-    
+public class ScimarkMonteCarloTask extends ComputeTask {
+	public ScimarkMonteCarloTask(Adaptor adaptor) {
+		super(adaptor);
+		// TODO Auto-generated constructor stub
+	}
+	
+	public String getTaskName() {
+		return "scimark.monte_carlo";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {
+		return new SingleComputeTask();
+	}
+
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		final static int SEED = 113;
+		
+		public final double num_flops(int Num_samples) {
+			// 3 flops in x^2+y^2 and 1 flop in random routine
+
+			return ((double) Num_samples)* 4.0;
+
+		}
+
+		public final double integrate(int numSamples) {
+
+			Random R = new Random(SEED);
+
+			int underCurve = 0;
+			for (int count = 0; count < numSamples; count++) {
+
+				double x = R.nextDouble();
+				double y = R.nextDouble();
+
+				if ( x*x + y*y <= 1.0) {
+					underCurve ++;
+				}
+			}
+			return ((double) underCurve / numSamples) * 4.0;
+		}
+
+		public double measureMonteCarlo(double min_time, Random R) {
+			Stopwatch Q = new Stopwatch();
+
+			// Cycles set to integrate into SPECjvm2008 benchmark harness.  Testing done on
+			// Apple Macbook Pro 2.0Ghz Intel Core Duo, 1GB 667mhz SODIMM
+			// J2SE 5.0_06 (Apple)
+			// Tuning: -server
+			int cycles=16777216;
+			double x =0.0;
+
+			Q.start();
+			x = integrate(cycles);
+			Q.stop();
+
+			return num_flops(cycles) / Q.read() * 1.0e-6;
+		}
+		
+		public void realRun() {
+			double min_time = Constants.RESOLUTION_DEFAULT;
+
+			// run the benchmark
+
+			double res = 0.0;
+			Random R = new Random(Constants.RANDOM_SEED);
+			res = measureMonteCarlo(min_time, R);
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		ScimarkMonteCarloTask task = new ScimarkMonteCarloTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
 }
 
 
diff -rupN ./src/org/cloudcmp/tasks/compute/scimark/sor/ScimarkSORTask.java ./src/org/cloudcmp/tasks/compute_full/scimark/sor/ScimarkSORTask.java
--- ./src/org/cloudcmp/tasks/compute/scimark/sor/ScimarkSORTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/scimark/sor/ScimarkSORTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -6,108 +6,130 @@
  *
  * This source code is provided as is, without any express or implied warranty.
  */
-package spec.benchmarks.scimark.sor;
+package org.cloudcmp.tasks.compute.scimark.sor;
+
+import java.util.Map;
+
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+import org.cloudcmp.tasks.compute.scimark.utils.*;
+
+public class ScimarkSORTask extends ComputeTask {
+	public ScimarkSORTask(Adaptor adaptor) {
+		super(adaptor);
+		// TODO Auto-generated constructor stub
+	}
+
+	public String getTaskName() {
+		return "scimark.sor";
+	}
+	int id = 0;
+
+	protected SingleComputeTask getSingleComputeTask() {		
+		return new SingleComputeTask();
+	}
+
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		public final double num_flops(int M, int N, int num_iterations) {
+			double Md = (double) M;
+			double Nd = (double) N;
+			double num_iterD = (double) num_iterations;
+
+			return (Md-1)*(Nd-1)*num_iterD*6.0;
+		}
+
+		public final double execute(double omega, double G[][], int
+				num_iterations) {
+			int M = G.length;
+			int N = G[0].length;
+
+			double omega_over_four = omega * 0.25;
+			double one_minus_omega = 1.0 - omega;
+			double [] Gi = null;
+			double Gi_Sum = 0.0;
+			// update interior points
+			//
+			int Mm1 = M-1;
+			int Nm1 = N-1;
+			for (int p=0; p<num_iterations; p++) {
+				for (int i=1; i<Mm1; i++) {
+					Gi = G[i];
+					double[] Gim1 = G[i-1];
+					double[] Gip1 = G[i+1];
+					for (int j=1; j<Nm1; j++)
+						Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j-1]
+								+ Gi[j+1]) + one_minus_omega * Gi[j];
+				}
+			}
+			for(int k=0;k<Gi.length;k++)Gi_Sum += Gi[k];
+
+			return Gi_Sum;
+				}
+
+//		private static final ThreadLocal <double[][]> threadLocalMatrix =
+//			new ThreadLocal<double[][]> () {
+//				@Override protected double[][] initialValue() {
+//					return new double[kernel.CURRENT_SOR_SIZE][kernel.CURRENT_SOR_SIZE];
+//				}
+//			};
+		
+		private double G[][] = new double[kernel.CURRENT_SOR_SIZE][kernel.CURRENT_SOR_SIZE];
+			
+		public double measureSOR(int N, double min_time, Random R) {
+			if(G.length != N){
+				G = new double[N][N];				
+			}
+			G = kernel.RandomizeMatrix(G, R);
+
+			Stopwatch Q = new Stopwatch();
+			int cycles=256;
+			//while(true)
+			//{
+			Q.start();
+			double x = execute(1.25, G, cycles);
+			Q.stop();
+			//	if (Q.read() >= min_time) break;
+
+			//	cycles *= 2;
+			//}
+			//System.out.println("SOR cycles = " + cycles);
+			// approx Mflops
+			kernel.checkResults(kernel.CURRENT_SOR_RESULT, "" + x, id);
+			return num_flops(N, N, cycles) / Q.read() * 1.0e-6;
+		}
+		
+		public void realRun() {
+			// default to the (small) cache-contained version
+
+			double min_time = Constants.RESOLUTION_DEFAULT;
+			int SOR_size =  kernel.CURRENT_SOR_SIZE;
+			// run the benchmark
+
+			double res = 0.0;
+			Random R = new Random(Constants.RANDOM_SEED);
+			res = measureSOR( SOR_size, min_time, R);
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		ScimarkSORTask task = new ScimarkSORTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
+
 
-import spec.benchmarks.scimark.utils.Constants;
-import spec.benchmarks.scimark.utils.Random;
-import spec.benchmarks.scimark.utils.Stopwatch;
-import spec.benchmarks.scimark.utils.kernel;
-
-public class SOR {
-    int id;
-    
-    public SOR(int id) {
-        this.id = id;
-    }
-    
-    public static void main(int id) {
-        SOR sor = new SOR(id);
-        sor.run();
-    }
-    public final double num_flops(int M, int N, int num_iterations) {
-        double Md = (double) M;
-        double Nd = (double) N;
-        double num_iterD = (double) num_iterations;
-        
-        return (Md-1)*(Nd-1)*num_iterD*6.0;
-    }
-    
-    public final double execute(double omega, double G[][], int
-            num_iterations) {
-        int M = G.length;
-        int N = G[0].length;
-        
-        double omega_over_four = omega * 0.25;
-        double one_minus_omega = 1.0 - omega;
-        double [] Gi = null;
-        double Gi_Sum = 0.0;
-        // update interior points
-        //
-        int Mm1 = M-1;
-        int Nm1 = N-1;
-        for (int p=0; p<num_iterations; p++) {
-            for (int i=1; i<Mm1; i++) {
-                Gi = G[i];
-                double[] Gim1 = G[i-1];
-                double[] Gip1 = G[i+1];
-                for (int j=1; j<Nm1; j++)
-                    Gi[j] = omega_over_four * (Gim1[j] + Gip1[j] + Gi[j-1]
-                            + Gi[j+1]) + one_minus_omega * Gi[j];
-            }
-        }
-        for(int k=0;k<Gi.length;k++)Gi_Sum += Gi[k];
-        
-        return Gi_Sum;
-    }
-    
-    private static final ThreadLocal <double[][]> threadLocalMatrix =
-            new ThreadLocal<double[][]> () {
-        @Override protected double[][] initialValue() {
-            return new double[kernel.CURRENT_SOR_SIZE][kernel.CURRENT_SOR_SIZE];
-        }
-    };
-    public double measureSOR(int N, double min_time, Random R) {
-        double G[][];
-        G = threadLocalMatrix.get();
-        if(G.length != N){
-            System.out.println("G.length: " + G.length + " N: " + N);
-            G = new double[N][N];
-            threadLocalMatrix.set(G);
-        }
-        G = kernel.RandomizeMatrix(G, R);
-        
-        Stopwatch Q = new Stopwatch();
-        int cycles=256;
-        //while(true)
-        //{
-        Q.start();
-        double x = execute(1.25, G, cycles);
-        Q.stop();
-        //	if (Q.read() >= min_time) break;
-        
-        //	cycles *= 2;
-        //}
-        //System.out.println("SOR cycles = " + cycles);
-        // approx Mflops
-        kernel.checkResults(kernel.CURRENT_SOR_RESULT, "" + x, id);
-        return num_flops(N, N, cycles) / Q.read() * 1.0e-6;
-    }
-    
-    public void run() {
-        // default to the (small) cache-contained version
-        
-        double min_time = Constants.RESOLUTION_DEFAULT;
-        int SOR_size =  kernel.CURRENT_SOR_SIZE;
-        // run the benchmark
-        
-        double res = 0.0;
-        Random R = new Random(Constants.RANDOM_SEED);
-        res = measureSOR( SOR_size, min_time, R);
-        
-        
-        
-        
-        
-    }
 }
 
diff -rupN ./src/org/cloudcmp/tasks/compute/scimark/sparse/ScimarkSparseTask.java ./src/org/cloudcmp/tasks/compute_full/scimark/sparse/ScimarkSparseTask.java
--- ./src/org/cloudcmp/tasks/compute/scimark/sparse/ScimarkSparseTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/scimark/sparse/ScimarkSparseTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -7,154 +7,169 @@
  * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks.scimark.sparse;
+package org.cloudcmp.tasks.compute.scimark.sparse;
 
-import spec.benchmarks.scimark.utils.Constants;
-import spec.benchmarks.scimark.utils.Random;
-import spec.benchmarks.scimark.utils.Stopwatch;
-import spec.benchmarks.scimark.utils.kernel;
-
-public class SparseCompRow {
-    int id;
-    
-    public SparseCompRow(int id) {
-        this.id = id;
-    }
-    
-    public static void main(int id) {
-        SparseCompRow sparse= new SparseCompRow(id);
-        sparse.run();
-    }
-        /* multiple iterations used to make kernel have roughly
-                same granulairty as other Scimark kernels. */
-    
-    public double num_flops(int N, int nz, int num_iterations) {
-                /* Note that if nz does not divide N evenly, then the
-                   actual number of nonzeros used is adjusted slightly.
-                 */
-        int actual_nz = (nz/N) * N;
-        return ((double)actual_nz) * 2.0 * ((double) num_iterations);
-    }
-    
-    
-        /* computes  a matrix-vector multiply with a sparse matrix
-                held in compress-row format.  If the size of the matrix
-                in MxN with nz nonzeros, then the val[] is the nz nonzeros,
-                with its ith entry in column col[i].  The integer vector row[]
-                is of size M+1 and row[i] points to the begining of the
-                ith row in col[].
-         */
-    
-    public void matmult( double y[], double val[], int row[],
-            int col[], double x[], int NUM_ITERATIONS, int call_count) {
-        double total = 0.0;
-        int M = row.length - 1;
-        for (int reps=0; reps<NUM_ITERATIONS; reps++) {
-            
-            for (int r=0; r<M; r++) {
-                double sum = 0.0;
-                int rowR = row[r];
-                int rowRp1 = row[r+1];
-                for (int i=rowR; i<rowRp1; i++)
-                    sum += x[ col[i] ] * val[i];
-                y[r] = sum;
-            }
-        }
-        if(call_count==1){
-            for(int i=0;i < y.length;i++)total += y[i];
-            kernel.checkResults(kernel.CURRENT_SPARSE_RESULT, "" + total, id);
-        }
-        
-        
-    }
-    public double measureSparseMatmult(int N, int nz,
-            double min_time, Random R) {
-        // initialize vector multipliers and storage for result
-        // y = A*y;
-        
-        double x[] = kernel.RandomVector(N, R);
-        double y[] = new double[N];
-        
-        // initialize square sparse matrix
-        //
-        // for this test, we create a sparse matrix wit M/nz nonzeros
-        // per row, with spaced-out evenly between the begining of the
-        // row to the main diagonal.  Thus, the resulting pattern looks
-        // like
-        //             +-----------------+
-        //             +*                +
-        //             +***              +
-        //             +* * *            +
-        //             +** *  *          +
-        //             +**  *   *        +
-        //             +* *   *   *      +
-        //             +*  *   *    *    +
-        //             +*   *    *    *  +
-        //             +-----------------+
-        //
-        // (as best reproducible with integer artihmetic)
-        // Note that the first nr rows will have elements past
-        // the diagonal.
-        
-        int nr = nz/N; 		// average number of nonzeros per row
-        int anz = nr *N;   // _actual_ number of nonzeros
-        
-        
-        double val[] = kernel.RandomVector(anz, R);
-        int col[] = new int[anz];
-        int row[] = new int[N+1];
-        
-        row[0] = 0;
-        for (int r=0; r<N; r++) {
-            // initialize elements for row r
-            
-            int rowr = row[r];
-            row[r+1] = rowr + nr;
-            int step = r/ nr;
-            if (step < 1) step = 1;   // take at least unit steps
-            
-            
-            for (int i=0; i<nr; i++)
-                col[rowr+i] = i*step;
-            
-        }
-        
-        Stopwatch Q = new Stopwatch();
-        
-        // Cycles set to integrate into SPECjvm2008 benchmark harness.  Testing done on
-        // Apple Macbook Pro 2.0Ghz Intel Core Duo, 1GB 667mhz SODIMM
-        
-        int cycles=512;
-        int count = 1;
-        //while(true)
-        //{
-        Q.start();
-        matmult(y, val, row, col, x, cycles, count++);
-        Q.stop();
-        
-        return num_flops(N, nz, cycles) / Q.read() * 1.0e-6;
-    }
-    
-    public void run() {
-        // default to the (large) cache-contained version
-        
-        double min_time = Constants.RESOLUTION_DEFAULT;
-        int Sparse_size_M = kernel.CURRENT_SPARSE_SIZE_M;
-        int Sparse_size_nz = kernel.CURRENT_SPARSE_SIZE_nz;
-        // run the benchmark
-        
-        double res = 0.0;
-        Random R = new Random(Constants.RANDOM_SEED);
-        res = measureSparseMatmult( Sparse_size_M,
-                Sparse_size_nz, min_time, R);
-        
-        
-        
-        //System.out.println("Sparse matmult (N="+ Sparse_size_M+
-        //                   ", nz=" + Sparse_size_nz + "): " + res);
-        
-        
-        
-    }
-    
+import java.util.Map;
+
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+import org.cloudcmp.tasks.compute.scimark.utils.*;
+
+public class ScimarkSparseTask extends ComputeTask {
+	public ScimarkSparseTask(Adaptor adaptor) {
+		super(adaptor);
+		// TODO Auto-generated constructor stub
+	}
+
+	public String getTaskName() {
+		return "scimark.sparse";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {		
+		return new SingleComputeTask();
+	}
+	
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		int id = 0;
+		/* multiple iterations used to make kernel have roughly
+		   same granulairty as other Scimark kernels. */
+
+		public double num_flops(int N, int nz, int num_iterations) {
+			/* Note that if nz does not divide N evenly, then the
+			   actual number of nonzeros used is adjusted slightly.
+			   */
+			int actual_nz = (nz/N) * N;
+			return ((double)actual_nz) * 2.0 * ((double) num_iterations);
+		}
+
+
+		/* computes  a matrix-vector multiply with a sparse matrix
+		   held in compress-row format.  If the size of the matrix
+		   in MxN with nz nonzeros, then the val[] is the nz nonzeros,
+		   with its ith entry in column col[i].  The integer vector row[]
+		   is of size M+1 and row[i] points to the begining of the
+		   ith row in col[].
+		   */
+
+		public void matmult( double y[], double val[], int row[],
+				int col[], double x[], int NUM_ITERATIONS, int call_count) {
+			double total = 0.0;
+			int M = row.length - 1;
+			for (int reps=0; reps<NUM_ITERATIONS; reps++) {
+
+				for (int r=0; r<M; r++) {
+					double sum = 0.0;
+					int rowR = row[r];
+					int rowRp1 = row[r+1];
+					for (int i=rowR; i<rowRp1; i++)
+						sum += x[ col[i] ] * val[i];
+					y[r] = sum;
+				}
+			}
+			if(call_count==1){
+				for(int i=0;i < y.length;i++)total += y[i];
+				kernel.checkResults(kernel.CURRENT_SPARSE_RESULT, "" + total, id);
+			}
+
+
+		}
+		public double measureSparseMatmult(int N, int nz,
+				double min_time, Random R) {
+			// initialize vector multipliers and storage for result
+			// y = A*y;
+
+			double x[] = kernel.RandomVector(N, R);
+			double y[] = new double[N];
+
+			// initialize square sparse matrix
+			//
+			// for this test, we create a sparse matrix wit M/nz nonzeros
+			// per row, with spaced-out evenly between the begining of the
+			// row to the main diagonal.  Thus, the resulting pattern looks
+			// like
+			//             +-----------------+
+			//             +*                +
+			//             +***              +
+			//             +* * *            +
+			//             +** *  *          +
+			//             +**  *   *        +
+			//             +* *   *   *      +
+			//             +*  *   *    *    +
+			//             +*   *    *    *  +
+			//             +-----------------+
+			//
+			// (as best reproducible with integer artihmetic)
+			// Note that the first nr rows will have elements past
+			// the diagonal.
+
+			int nr = nz/N; 		// average number of nonzeros per row
+			int anz = nr *N;   // _actual_ number of nonzeros
+
+
+			double val[] = kernel.RandomVector(anz, R);
+			int col[] = new int[anz];
+			int row[] = new int[N+1];
+
+			row[0] = 0;
+			for (int r=0; r<N; r++) {
+				// initialize elements for row r
+
+				int rowr = row[r];
+				row[r+1] = rowr + nr;
+				int step = r/ nr;
+				if (step < 1) step = 1;   // take at least unit steps
+
+
+				for (int i=0; i<nr; i++)
+					col[rowr+i] = i*step;
+
+			}
+
+			Stopwatch Q = new Stopwatch();
+
+			// Cycles set to integrate into SPECjvm2008 benchmark harness.  Testing done on
+			// Apple Macbook Pro 2.0Ghz Intel Core Duo, 1GB 667mhz SODIMM
+
+			int cycles=512;
+			int count = 1;
+			//while(true)
+			//{
+			Q.start();
+			matmult(y, val, row, col, x, cycles, count++);
+			Q.stop();
+
+			return num_flops(N, nz, cycles) / Q.read() * 1.0e-6;
+		}
+		
+		public void realRun() {
+			double min_time = Constants.RESOLUTION_DEFAULT;
+			int Sparse_size_M = kernel.CURRENT_SPARSE_SIZE_M;
+			int Sparse_size_nz = kernel.CURRENT_SPARSE_SIZE_nz;
+			// run the benchmark
+
+			double res = 0.0;
+			Random R = new Random(Constants.RANDOM_SEED);
+			res = measureSparseMatmult( Sparse_size_M,
+					Sparse_size_nz, min_time, R);
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		ScimarkSparseTask task = new ScimarkSparseTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
 }
diff -rupN ./src/org/cloudcmp/tasks/compute/scimark/utils/Constants.java ./src/org/cloudcmp/tasks/compute_full/scimark/utils/Constants.java
--- ./src/org/cloudcmp/tasks/compute/scimark/utils/Constants.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/scimark/utils/Constants.java	2011-11-16 17:05:00.000000000 -0500
@@ -4,7 +4,7 @@
  *
  * This source code is provided as is, without any express or implied warranty.
  */
-package spec.benchmarks.scimark.utils;
+package org.cloudcmp.tasks.compute.scimark.utils;
 
 public class Constants {
     public static final double RESOLUTION_DEFAULT = 2.0;  /*secs*/
diff -rupN ./src/org/cloudcmp/tasks/compute/scimark/utils/kernel.java ./src/org/cloudcmp/tasks/compute_full/scimark/utils/kernel.java
--- ./src/org/cloudcmp/tasks/compute/scimark/utils/kernel.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/scimark/utils/kernel.java	2011-11-16 17:05:00.000000000 -0500
@@ -4,10 +4,7 @@
  *
  * This source code is provided as is, without any express or implied warranty.
  */
-package spec.benchmarks.scimark.utils;
-
-import spec.harness.Context;
-import spec.harness.Util;
+package org.cloudcmp.tasks.compute.scimark.utils;
 
 public class kernel {
     // each measurement returns approx Mflops
@@ -134,8 +131,7 @@ public class kernel {
     public static int MC_LOOPS = 10;  
     
     public static void init() {
-        String currentDataset = Util.getProperty(spec.harness.Constants.SCIMARK_SIZE_PROP,
-                Constants.DEFAULT_DATASET_NAME);
+        String currentDataset = Constants.DEFAULT_DATASET_NAME;
         if (Constants.SMALL_DATASET_NAME.equals(currentDataset)) {
             CURRENT_FFT_SIZE = Constants.SMALL_FFT_SIZE;
             CURRENT_SOR_SIZE = Constants.SMALL_SOR_SIZE;
@@ -194,13 +190,5 @@ public class kernel {
     
     
     public static final void checkResults(String expectedValue, String gottenValue, int loop) {
-        if (expectedValue.equals(gottenValue)) {
-            if (loop == 1) {
-                Context.getOut().println(Constants.VERIFICATION_PASSED_MESSAGE);
-            }
-        } else {
-            Context.getOut().println(Constants.VERIFICATION_FAILED_MESSAGE
-                    + "The result is "  + gottenValue + "  instead of " + expectedValue);
-        }
     }
 }
diff -rupN ./src/org/cloudcmp/tasks/compute/scimark/utils/Random.java ./src/org/cloudcmp/tasks/compute_full/scimark/utils/Random.java
--- ./src/org/cloudcmp/tasks/compute/scimark/utils/Random.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/scimark/utils/Random.java	2011-11-16 17:05:00.000000000 -0500
@@ -4,7 +4,7 @@
  *
  * This source code is provided as is, without any express or implied warranty.
  */
-package spec.benchmarks.scimark.utils;
+package org.cloudcmp.tasks.compute.scimark.utils;
 
 /*
  * Random.java based on Java Numerical Toolkit (JNT) Random.UniformSequence
diff -rupN ./src/org/cloudcmp/tasks/compute/scimark/utils/Stopwatch.java ./src/org/cloudcmp/tasks/compute_full/scimark/utils/Stopwatch.java
--- ./src/org/cloudcmp/tasks/compute/scimark/utils/Stopwatch.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/scimark/utils/Stopwatch.java	2011-11-16 17:05:00.000000000 -0500
@@ -4,7 +4,7 @@
  *
  * This source code is provided as is, without any express or implied warranty.
  */
-package spec.benchmarks.scimark.utils;
+package org.cloudcmp.tasks.compute.scimark.utils;
 
 /**
  *
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/Child.java ./src/org/cloudcmp/tasks/compute_full/serial/data/Child.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/Child.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/Child.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/Handler.java ./src/org/cloudcmp/tasks/compute_full/serial/data/Handler.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/Handler.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/Handler.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/InterfaceForProxy.java ./src/org/cloudcmp/tasks/compute_full/serial/data/InterfaceForProxy.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/InterfaceForProxy.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/InterfaceForProxy.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 /**
  * $Id: InterfaceForProxy.java,v 1.1 2005/08/26 19:47:38 csuconic Exp $
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/ProxiedClass.java ./src/org/cloudcmp/tasks/compute_full/serial/data/ProxiedClass.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/ProxiedClass.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/ProxiedClass.java	2011-11-16 17:05:00.000000000 -0500
@@ -7,7 +7,7 @@
  * Used by SPEC in the SPECjvm2008 project on permission by the author Clebert Suconi.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 import java.lang.reflect.Proxy;
@@ -24,7 +24,7 @@ public class ProxiedClass implements Int
         this.value=value;
     }
     /** It always return value.
-     *  {@link spec.benchmarks.serial.data.TestHandler} will multiply this
+     *  {@link serial.data.TestHandler} will multiply this
      *  by a factor and we will use that value to test
      *  if the value is being used or not.
      */
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestArrayDouble.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestArrayDouble.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestArrayDouble.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestArrayDouble.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 import java.util.Random;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestArray.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestArray.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestArray.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestArray.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 import java.util.Random;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestArrayList.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestArrayList.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestArrayList.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestArrayList.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.util.ArrayList;
 import java.util.Random;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestBigInteger.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestBigInteger.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestBigInteger.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestBigInteger.java	2011-11-16 17:05:00.000000000 -0500
@@ -4,7 +4,7 @@
  * Distributable under LGPL license.
  * See terms of license at gnu.org.
  */
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 import java.math.BigInteger;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestByteArray.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestByteArray.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestByteArray.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestByteArray.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.util.Random;
 
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestClassReferenceTest.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestClassReferenceTest.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestClassReferenceTest.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestClassReferenceTest.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestClassWithSQLDateOnly.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestClassWithSQLDateOnly.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestClassWithSQLDateOnly.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestClassWithSQLDateOnly.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestDomainObject.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestDomainObject.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestDomainObject.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestDomainObject.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 import java.util.Random;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestExceptionReference.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestExceptionReference.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestExceptionReference.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestExceptionReference.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.IOException;
 import java.util.Random;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestExternalizable.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestExternalizable.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestExternalizable.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestExternalizable.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Externalizable;
 import java.io.ObjectOutput;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestHandler.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestHandler.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestHandler.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestHandler.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestHugeData.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestHugeData.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestHugeData.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestHugeData.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 import java.util.ArrayList;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestParent.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestParent.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestParent.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestParent.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 import java.util.HashMap;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestPayload.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestPayload.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestPayload.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestPayload.java	2011-11-16 17:05:00.000000000 -0500
@@ -2,7 +2,7 @@
  * Distributable under LGPL license.
  * See terms of license at gnu.org.
  */
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 import java.util.Random;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestProxy.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestProxy.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestProxy.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestProxy.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 
 import java.util.Random;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestReadResolve.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestReadResolve.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestReadResolve.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestReadResolve.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestSimple.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestSimple.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestSimple.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestSimple.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.io.Serializable;
 import java.util.Random;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestWithBigDecimal.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestWithBigDecimal.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestWithBigDecimal.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestWithBigDecimal.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.math.BigDecimal;
 import java.util.Random;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/data/TestWithFinalField.java ./src/org/cloudcmp/tasks/compute_full/serial/data/TestWithFinalField.java
--- ./src/org/cloudcmp/tasks/compute/serial/data/TestWithFinalField.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/data/TestWithFinalField.java	2011-11-16 17:05:00.000000000 -0500
@@ -5,7 +5,7 @@
  * See terms of license at gnu.org.
  */
 
-package spec.benchmarks.serial.data;
+package org.cloudcmp.tasks.compute.serial.data;
 
 import java.util.Random;
 import java.io.Serializable;
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/SerialTask.java ./src/org/cloudcmp/tasks/compute_full/serial/SerialTask.java
--- ./src/org/cloudcmp/tasks/compute/serial/SerialTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/SerialTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -4,98 +4,113 @@
  *
  * This source code is provided as is, without any express or implied warranty.
  */
-package spec.benchmarks.serial;
+package org.cloudcmp.tasks.compute.serial;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.util.BitSet;
+import java.util.Map;
 
-import spec.harness.Context;
-import spec.harness.Launch;
-import spec.harness.SpecJVMBenchmarkBase;
-import spec.harness.StopBenchmarkException;
-import spec.harness.results.BenchmarkResult;
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
+
+public class SerialTask extends ComputeTask {
+	public SerialTask(Adaptor adaptor) {
+		super(adaptor);
+		// TODO Auto-generated constructor stub
+	}
+	
+	public String getTaskName() {
+		return "serial";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {		
+		return new SingleComputeTask();
+	}
 
-public class Main extends SpecJVMBenchmarkBase {
 	static boolean doEquals=true;
-    
-    /** Run this in mutli mode, next to each other. */
-    public static String testType() {
-        return MULTI;
-    }
-       
-    public static void main(String[] args) {
-        runSimple(Main.class, args);
-    }
-    
-    public static Object[][] instances;
-    public static ByteArrayOutputStream[] streams;
-    public Object[] threadInstances;
-    ByteArrayOutputStream bos;
-    
-    public Main(BenchmarkResult bmResult, int threadId) {
-        super(bmResult, threadId);       
-        threadInstances = instances[threadId - 1];     
-        bos = streams[threadId - 1]; 
-    }
-    
-    public void harnessMain() {
-    	try {
-            serialize();
-            serialize();
-            serialize();
-    	} catch (Exception e) {
-    		e.printStackTrace(Context.getOut());
-    	}
-    }
-    
-    public static void setupBenchmark(){    	
-        int threads = Launch.currentNumberBmThreads;
-        instances = new Object[threads][Utils.classesNumber];
-        streams = new ByteArrayOutputStream[threads];       
-        try {      
-            for (int i = 0; i < threads; i ++) {          	
-        	    instances[i] = Utils.createInstances();
-        	    streams[i] = new ByteArrayOutputStream() {
-        	    	public synchronized byte[] toByteArray() {
-        	    		return buf;
-        	    	}
-        	    };
-            }    
-        } catch (Exception e) {
-        	e.printStackTrace();
-        	throw new StopBenchmarkException("error in setupBenchmark of serial workload");
-        }
-    }
-    
-    
-    public void serialize() throws Exception {    	
-    	BitSet result = Utils.createBitSet();
-    	bos.reset();
-    	ObjectOutputStream oos = new ObjectOutputStream(bos);    	
-    	for (int i = 0; i < Utils.singleLoop; i ++) {
-    	    for (int j = 0; j < threadInstances.length; j ++) {
-    	    	oos.writeObject(threadInstances[j]);
-    	    }
-    	    oos.flush();
-    	    oos.reset();
-    	}   	
-    	
-    	ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray(), 0, bos.size());
-    	ObjectInputStream ois = new ObjectInputStream(bis);
-    	for (int i = 0; i < Utils.singleLoop; i ++) {    		
-    	    for (int j = 0; j < threadInstances.length; j ++) {
-    	    	Object obj = ois.readObject();   
-    	    	if (doEquals) {   	    		
-    	    	    result.set(j, result.get(j) && obj.equals(threadInstances[j]));
-    	    	}    
-    	    }
-    	    
-    	}
-    	oos.close();
-    	ois.close();    	
-    	Utils.printResult(Context.getOut(), result);
-    }	
+
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		public Object[][] instances;
+		public ByteArrayOutputStream[] streams;
+		public Object[] threadInstances;
+		ByteArrayOutputStream bos;
+
+		public void setupBenchmark(){    	
+			int threads = 1;
+			instances = new Object[threads][Utils.classesNumber];
+			streams = new ByteArrayOutputStream[threads];       
+			try {      
+				for (int i = 0; i < threads; i ++) {          	
+					instances[i] = Utils.createInstances();
+					streams[i] = new ByteArrayOutputStream() {
+						public synchronized byte[] toByteArray() {
+							return buf;
+						}
+					};
+				}    
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+
+
+		public void serialize() throws Exception {    	
+			BitSet result = Utils.createBitSet();
+			bos.reset();
+			ObjectOutputStream oos = new ObjectOutputStream(bos);    	
+			for (int i = 0; i < Utils.singleLoop; i ++) {
+				for (int j = 0; j < threadInstances.length; j ++) {
+					oos.writeObject(threadInstances[j]);
+				}
+				oos.flush();
+				oos.reset();
+			}   	
+
+			ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray(), 0, bos.size());
+			ObjectInputStream ois = new ObjectInputStream(bis);
+			for (int i = 0; i < Utils.singleLoop; i ++) {    		
+				for (int j = 0; j < threadInstances.length; j ++) {
+					Object obj = ois.readObject();   
+					if (doEquals) {   	    		
+						result.set(j, result.get(j) && obj.equals(threadInstances[j]));
+					}    
+				}
+
+			}
+			oos.close();
+			ois.close();    	
+		}	
+		
+		public void realRun() {
+			setupBenchmark();
+			try {
+				serialize();
+				serialize();
+				serialize();
+			} catch (Exception e) {
+			}
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		SerialTask task = new SerialTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
 }
diff -rupN ./src/org/cloudcmp/tasks/compute/serial/Utils.java ./src/org/cloudcmp/tasks/compute_full/serial/Utils.java
--- ./src/org/cloudcmp/tasks/compute/serial/Utils.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/serial/Utils.java	2011-11-16 17:05:00.000000000 -0500
@@ -1,4 +1,4 @@
-package spec.benchmarks.serial;
+package org.cloudcmp.tasks.compute.serial;
 /*
  * Copyright (c) 2008 Standard Performance Evaluation Corporation (SPEC)
  *               All rights reserved.
@@ -22,7 +22,7 @@ public class Utils {
         
     public static int classesNumber = classNames.length;
     
-    public static final String dataPackagePrefix = "spec.benchmarks.serial.data.";
+    public static final String dataPackagePrefix = "org.cloudcmp.tasks.compute.serial.data.";
     
     public static final int singleLoop = 1000;
     
@@ -55,4 +55,4 @@ public class Utils {
         }
         return result;
     }
-}
\ No newline at end of file
+}
diff -rupN ./src/org/cloudcmp/tasks/compute/sunflow/SunflowTask.java ./src/org/cloudcmp/tasks/compute_full/sunflow/SunflowTask.java
--- ./src/org/cloudcmp/tasks/compute/sunflow/SunflowTask.java	2011-11-16 17:32:46.000000000 -0500
+++ ./src/org/cloudcmp/tasks/compute_full/sunflow/SunflowTask.java	2011-11-16 17:05:00.000000000 -0500
@@ -7,69 +7,81 @@
  * This source code is provided as is, without any express or implied warranty.
  */
 
-package spec.benchmarks.sunflow;
+package org.cloudcmp.tasks.compute.sunflow;
 
+import java.util.Map;
 
+import org.cloudcmp.Adaptor;
+import org.cloudcmp.tasks.compute.ComputeTask;
 import org.sunflow.Benchmark;
 import org.sunflow.system.UI;
 import org.sunflow.system.UI.Module;
 import org.sunflow.system.UI.PrintLevel;
 
-import spec.harness.Constants;
-import spec.harness.Context;
-import spec.harness.Launch;
-import spec.harness.SpecJVMBenchmarkBase;
-import spec.harness.Util;
-import spec.harness.results.BenchmarkResult;
-
-
-public class Main extends SpecJVMBenchmarkBase {
-    public static final int resolution = 128;
-    private static Benchmark[] benchmarks;   
-    
-    /** Run this in single mode, multi threading is handled by the benchmark. */
-    public static String testType() {
-        return MULTI;
-    }
-    
-    static class BenchmarkImpl extends Benchmark{
-        public BenchmarkImpl(int resolution, boolean showOutput, boolean showBenchmarkOutput,
-                boolean saveOutput, int threads) {
-            super(resolution, showOutput, showBenchmarkOutput, saveOutput, threads);
-        }
-        
-        public void print(Module m, PrintLevel level, String s) {
-            if (!s.startsWith("Loading reference image from") && m == Module.BENCH) {
-                Context.getOut().println(UI.formatOutput(m, level, s));
-            }
-            if (level == PrintLevel.ERROR)
-                Context.getOut().println("ERROR...");
-        }
-    }
-    
-    Benchmark benchmark;
-    
-    public Main(BenchmarkResult bmResult, int threadId) {
-        super(bmResult, threadId);        
-        benchmark = benchmarks[threadId - 1];
-    }
-    
-    public static void setupBenchmark() { 
-    	int threads = Util.getIntProperty(Constants.SUNFLOW_THREADS, null);
-    	int bmThreads = Launch.currentNumberBmThreads;
-        benchmarks = new Benchmark[bmThreads];
-        for (int i = 0; i < bmThreads; i ++) {        	
-            benchmarks[i] = new BenchmarkImpl(resolution, false, true, false, threads);
-            benchmarks[i].kernelBegin();
-        }
-    }
-    
-    public void harnessMain() {
-        benchmark.kernelMain();
-        benchmark.kernelEnd();
-    }
-    
-    public static void main(String[] args) throws Exception {
-        runSimple(Main.class, args);
-    }
+public class SunflowTask extends ComputeTask {
+	public SunflowTask(Adaptor adaptor) {
+		super(adaptor);
+		// TODO Auto-generated constructor stub
+	}
+
+	public String getTaskName() {
+		return "sunflow";
+	}
+	
+	protected SingleComputeTask getSingleComputeTask() {		
+		return new SingleComputeTask();
+	}
+	
+	protected class SingleComputeTask extends ComputeTask.SingleComputeTask {
+		public static final int resolution = 128;
+		private Benchmark[] benchmarks;   
+
+		class BenchmarkImpl extends Benchmark{
+			public BenchmarkImpl(int resolution, boolean showOutput, boolean showBenchmarkOutput,
+					boolean saveOutput, int threads) {
+				super(resolution, showOutput, showBenchmarkOutput, saveOutput, threads);
+			}
+
+			public void print(Module m, PrintLevel level, String s) {
+			}
+		}
+
+		Benchmark benchmark;
+
+		public void setupBenchmark() { 
+			int threads = 1;
+			int bmThreads = 1;
+			benchmarks = new Benchmark[bmThreads];
+			for (int i = 0; i < bmThreads; i ++) {        	
+				benchmarks[i] = new BenchmarkImpl(resolution, false, true, false, threads);
+				benchmarks[i].kernelBegin();
+			}
+		}
+		
+		public void realRun() {
+			benchmark = new BenchmarkImpl(resolution, false, true, false, 1);
+			benchmark.kernelBegin();
+			benchmark.kernelMain();
+			benchmark.kernelEnd();
+		}
+	}
+	
+	public static void main(String [] args) {
+		if (args.length < 4) {
+			System.err.println("Arguments: [adaptor_name] [config_file] [num_threads] [num_runs]");
+			System.exit(1);
+		}
+		Adaptor adaptor = Adaptor.getAdaptorByName(args[0]);
+		if (adaptor == null) {
+			System.err.println("Unknown adaptor");
+			System.exit(1);
+		}
+		
+		adaptor.loadConfigFromFile(args[1]);		
+		SunflowTask task = new SunflowTask(adaptor);
+		task.configs.put("num_threads", args[2]);
+		task.configs.put("num_runs", args[3]);
+		Map<String, String> results = task.run();
+		ComputeTask.printResults(results);
+	}
 }
